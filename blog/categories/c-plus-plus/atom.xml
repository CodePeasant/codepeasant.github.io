<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c++ | 乌衣巷]]></title>
  <link href="http://CodePeasant.github.io/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://CodePeasant.github.io/"/>
  <updated>2014-11-20T17:13:55+08:00</updated>
  <id>http://CodePeasant.github.io/</id>
  <author>
    <name><![CDATA[吴逸翔]]></name>
    <email><![CDATA[1032197148@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[APUE笔记]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/10/31/APUE%E7%AC%94%E8%AE%B0/"/>
    <updated>2014-10-31T21:15:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/10/31/APUE笔记</id>
    <content type="html"><![CDATA[<h1>APUE笔记</h1>

<h2>1.UNIX System Overview</h2>

<h3>Nonfatal error(man 3 errno)</h3>

<ul>
<li>EAGAIN/EWOULDBLOCK</li>
<li>ENFILE/ENOBUFS/ENOLCK/ENOSPC/ENOSR/ENOMEM/EBUSY</li>
</ul>


<h3>键盘信号</h3>

<ul>
<li>Ctrl+Z SIGTSTP</li>
<li>Ctrl+C SIGINT</li>
<li>Ctrl+D EOF</li>
<li>Ctrl+/ SIGQUIT</li>
</ul>


<h2>2.UNIX Standardization and Implementations</h2>

<ul>
<li>ISO C/POSIX/XSI</li>
<li>FreeBSD/Linux/MacOS/Solaris</li>
<li>gcc -D_POSIX_C_SOURCE=200112 file.c</li>
</ul>


<h2>3.File I/O</h2>

<h3>open/close</h3>

<ul>
<li>O_RDONLY/O_WRONLY/O_RDWR</li>
<li>O_APPEND/O_TRUNC/O_CREAT/O_EXCL/O_NONBLOCK</li>
<li>O_SYNC(write data&amp;attr)/O_DSYNC(write data)/O_RSYNC(read)</li>
<li>sync(all)/fsync(single)/fdatasync</li>
</ul>


<h3>read/write</h3>

<h3>lseek</h3>

<ul>
<li>SEEK_CUR/SEEK_SET/SEEK_END</li>
<li>pread/pwrite: lseek+read/write</li>
</ul>


<h3>dup/dup2</h3>

<ul>
<li>dup(fd): fcntl(fd, O_DUPFD, 0)</li>
<li>dup2(fd1, fd2): close(fd2);fcntl(fd1, O_DUPFD, fd2)</li>
</ul>


<h3>fcntl</h3>

<ul>
<li>F_DUPFD</li>
<li>F_GETFD/F_SETFD(file descriptor, FD_CLOEXEC only)</li>
<li>F_GETFL/F_SETFL(file status, O_NONBLOCK and so on)</li>
<li>F_GETOWN/F_SETOWN</li>
<li>F_GETLK/F_SETLK/F_SETLKW</li>
<li>ioctl(driver, no need to known)</li>
</ul>


<h2>4.Files and Directories</h2>

<h3>stat(file path)/fstat(file decriptor id)/lstat(show symbolic link)</h3>

<ul>
<li>st_mode(file type&amp;permission)</li>
<li>st_ino/st_dev/st_rdev</li>
<li>st_nlink</li>
<li>st_uid/st_gid</li>
<li>st_size</li>
<li>st_atime[ls -u] last access , read()</li>
<li>st_mtime[ls] last modify, write()</li>
<li>st_ctime[ls -c] last inode status chagne, chown()</li>
<li>st_blksize</li>
<li>st_blocks(number of disk block allocate)</li>
</ul>


<h3>File Type</h3>

<ul>
<li>Regular file(S_ISREG)</li>
<li>Directory file(S_ISDIR)</li>
<li>Block special file(S_ISBLK)</li>
<li>Character special file(S_ISCHR)</li>
<li>FIFO(S_ISFIFO)[named pipe]</li>
<li>Socket(S_ISSOCK)</li>
<li>Symbolic link(S_ISLNK)</li>
</ul>


<h3>IPC</h3>

<ul>
<li>MQ message queue</li>
<li>SEM semaphore</li>
<li>SHM shared memory object</li>
</ul>


<h3>Process uid/gid</h3>

<ul>
<li>real userID/groudID(who excute the process)</li>
<li>effective userID/groupID(the permisson check)[by default is real userID/groupID, use set-user-id to be the file owner]</li>
<li>saved set-user-ID/groud-ID(save the last effective when effective change)</li>
<li>supplement group IDs</li>
</ul>


<h3>File Access Permissions</h3>

<ul>
<li>R:4, W :2, X:1</li>
<li>S_I(R/W/X)(USR/GRP/OTH)</li>
<li>open file need X for directory(if you known this file, R is no need)</li>
<li>list file need R for directory</li>
<li>create/ delete file need W&amp;X for directory, W for file is no need</li>
<li>access(path, mode): access permission test</li>
<li>umask(cmask): set the access permission for file this process create, turn off the bit in cmask</li>
<li>fchmod(fd, mode)</li>
</ul>


<h3>chown/fchown/lchown</h3>

<ul>
<li>chwon(path,owner,group)</li>
<li>chown -R user:group file/directory</li>
</ul>


<h3>file system</h3>

<ul>
<li>driver/parition(one file system per partition)/cylinde/(inodes+blocks)</li>
<li>a inode is a file, point to many data block</li>
<li>a inode can be link from many directory, when not process open the file and all directory unlink, delete the inode, but the data block still exist[hard link, just add st_nlink, create hard link for directory is not allowed]</li>
<li>symbolic link: add a new inode point to source file path, no add st_nlink</li>
<li>link(oldpath,newpath), symlink(actualpath,sympath), unlink(path), remove(path), rename(old,new)</li>
<li>mkdir/rmdir/chdir/fchdir/getcwd</li>
<li>opendir/readdir/rewinddir/closedir/telldir/seekdir</li>
<li>DIR structure like FILE, with the offset</li>
<li>st_dev: major is the disk num, minor is the filesystem num</li>
<li>st_rdev: valid for character device &amp; block device, the real device it is on</li>
</ul>


<h2>5.Standard I/O Library</h2>

<h3>Stream Buffer</h3>

<ul>
<li>Fully Buffered</li>
<li>Line Buffered</li>
<li>Unbuffered</li>
</ul>


<h3>Stream Read&amp;Write</h3>

<h4>Character-at-a-time I/O:</h4>

<ul>
<li>getc(fp)/fgetc(fp)/getchar()</li>
<li>getchar()=getc(STDIN)</li>
<li>getc is macro and fgetc is function, they are same</li>
<li>ungetc(c,fp)[put char back into stream]</li>
<li>putc(c, fp)/fputc(c, fp)/putchar&copy;</li>
</ul>


<h4>Line-at-a-time I/O:</h4>

<ul>
<li>fgets(buf,n,fp)</li>
<li>fputs(str,fp)</li>
</ul>


<h4>Direct I/O(Binary I/O):</h4>

<ul>
<li>fread(ptr, size, n, fp)</li>
<li>fwrite(ptr, size, n, fp)</li>
<li>ftell(fp)/fseek(fp, offset, whence)/rewind(fp)</li>
</ul>


<h3>Formatted I/O</h3>

<ul>
<li>printf(format, &hellip;)</li>
<li>fprintf(fp, format, ..)</li>
<li>sprintf(buf, format, ..)</li>
<li>snprintf(buf, n, format, &hellip;)</li>
<li>scanf(format, &hellip;)</li>
<li>fscanf(fp, format, &hellip;)</li>
<li>sscanf(buf, format, &hellip;)</li>
</ul>


<h3>Temporary Files</h3>

<ul>
<li>char *tmpname(ptr)</li>
<li>char *tempnam(directory, prefix)</li>
<li>File* tmpfile()</li>
<li>int mktemp(template)[return fd]</li>
<li>tmpname&amp;tempnam都有time window问题，应使用temfile&amp;mktemp</li>
</ul>


<h2>6.System Data Files and Information</h2>

<h3>Password File</h3>

<ul>
<li>passwd <em>getpwuid(uid)/passwd </em>getpwnam(name)</li>
<li>passwd *getpwent()[get by next, null return by end]</li>
<li>setpwent()[open/rewind]</li>
<li>endpwent()[close]</li>
</ul>


<h3>Shadow File(保存加密后的密码)</h3>

<ul>
<li>spwd *getspnam(name)</li>
<li>spwd *getspent()/setspent()/endspent()</li>
</ul>


<h3>Group File</h3>

<ul>
<li>group <em>getgrgid(gid)/group </em>getgrnam(name)</li>
<li>group *getgpent()/setgrent()/endgrent()</li>
<li>char **group->gr_mem指向属于本group的user_name</li>
<li>Supplementary Group IDs make a user can belong up to 16 addtional groups</li>
</ul>


<h3>Datetime</h3>

<ul>
<li>time_t time(time_t *) seconds from Epoch</li>
<li>gettimeofday(timeval *, NULL) seconds &amp; microseconds from Epoch</li>
<li>tm <em>gmtime(time_t </em>) time_t to tm UTC(calendar form)</li>
<li>tm <em>localtime(time_t </em>) time_t to tm local timezone</li>
<li>time_t mktime(tm *) tm to time_t</li>
<li>char <em>asctime(tm </em>) tm to string</li>
<li>char <em>ctime(time_t </em>) time_t to string</li>
<li>strftime(buf, maxsize, format, tm*) tm to format string</li>
</ul>


<h2>7.Process Environment</h2>

<h3>Process Termination</h3>

<ul>
<li>terminate method</li>
<li>return from main()</li>
<li>return from last thread</li>
<li>call exit()</li>
<li>call <em>exit()/</em>Exit()</li>
<li>call pthread_exit()</li>
<li>call abort</li>
<li>receipt a signal</li>
<li>last thread response for a cancel request</li>
<li>exit(0) is same as return 0 by main</li>
<li>exit will call exit handle register by atexit() and clean up standard I/O, <em>exit &amp; </em>Exit will not</li>
</ul>


<h3>Memory Layout(From low address to high)</h3>

<ul>
<li>Text Segment(Code Segment)</li>
<li>Initialized Data Segment(Data Segment)</li>
<li>Uninitialized Data Segment(Block Started by Symbol, BSS)</li>
<li>Heap</li>
<li>Stack</li>
</ul>


<h3>Memory Allocate</h3>

<ul>
<li>malloc(size)</li>
<li>cmalloc(nobj, size) malloc+memset(0)</li>
<li>remalloc(ptr,size)</li>
<li>free(ptr)</li>
</ul>


<h3>Environment Variables</h3>

<ul>
<li>int main(int argc, char <em>argv[], char </em>envp[])</li>
<li>getenv(name)/putenv(name=value)/setenv(name,value)/unsetenv(name)</li>
</ul>


<h3>Others</h3>

<ul>
<li>goto only available in same function, use setjmp/longjmp to cross function</li>
<li>getrlimit/setrlimit, return resource limit for the process(rlimit)</li>
<li>struct rlimit{
  rlim_t rlim_cur; //soft limit
  rlim_t rlim_max; //hard limit
}</li>
<li>soft limit should lower or equal to hard limit, only root user can change hard limit</li>
</ul>


<h2>8.Process Control</h2>

<h3>Process Identifier</h3>

<ul>
<li>getpid()/getppid()</li>
<li>getuid()/geteuid()</li>
<li>getgid()/getegid()</li>
</ul>


<h3>Process Creation</h3>

<ul>
<li>fork(), call once, return twice</li>
<li>parent &amp; child process by fork share Text Segment, other segment are independent, copy on write</li>
<li>parent &amp; child process share file discriptors open</li>
<li>signal &amp; File Lock are not inherited from parent to child</li>
<li>vfork(), the parent and child share all resource, the parent wait unit child exit, it always use to call exec()</li>
</ul>


<h3>Process Termination</h3>

<ul>
<li>wait(&amp;return_status), wait for any child terminated, return by the first child</li>
<li>waitpid(pid,&amp;return_status,option), wait for the specified child terminated</li>
<li>init process become parent for whos parent terminated</li>
<li>child process will be zombie when it terminate but parent not wait for it</li>
<li>child terminated then the process will receive SIGCHLD, default behavior is ignore it</li>
</ul>


<h3>Exec Function</h3>

<ul>
<li>exec[l/v]<a href="filepath,%20argv[],%20envp[]"> /e/p</a>, only execve is system call</li>
<li>exec function replace the text segment/data segment/bss/heap/stack by the programe specified by filepath</li>
<li>exec keep the file discriptor open, but fcntl FD_CLOEXEC can close them</li>
<li>#! /bin/sh</li>
<li>system = fork + exec + waitpid</li>
</ul>


<h3>Change user IDs and group IDs</h3>

<ul>
<li>setuid/setgid</li>
<li>uid or gid only can be set by root, or set to real-user/saved-user/file-owner-user</li>
</ul>


<h3>Accounting</h3>

<ul>
<li>real(实际运行时间)</li>
<li>user(用户态CPU时间)</li>
<li>sys(内核态CPU时间)</li>
</ul>


<h2>9.Process Relationships</h2>

<ul>
<li>ssh beyond tcp protocol</li>
<li>Terminal Login &amp; NetworkLogin(Pseudo Terminal)</li>
<li>a login is a session, a session contain some foreground/backgroud process groups, process groups include one or more process</li>
<li>$ proc1 | proc2 &amp; : proc1 and proc2 consist of a backgound group</li>
<li>$ proc3 | proc4 : proc3 and proc4 consist of a foregound group</li>
<li>Ctrl + C/Delete: send SIGINT to all foreground process</li>
<li>Ctrl + /: send SIGQUIT to all foreground process</li>
<li>Ctrl + Z: send SIGTSTP to all foreground process, 使用bg命令查询有哪些挂起的，使用fg命令重新带回前台</li>
<li>background process input/oupt to terminal wil send SIGTTIN/SIGTTOUT and then stop until use fg command to bring them to foreground</li>
</ul>


<h2>10.Signals</h2>

<h3>Generate</h3>

<ul>
<li>User inout from terminal</li>
<li>Hardware exception(invalid memory)</li>
<li>kill(1, command)/(2, function)</li>
<li>Software condition(SIGPIPE)</li>
</ul>


<h3>Behavior</h3>

<ul>
<li>Ignore(SIGKILL/SIGSTOP can&rsquo;t ignore)[SIG_IGN]</li>
<li>catch and deal[void (*func)(int)]</li>
<li>default action[SIG_DFL]</li>
</ul>


<h3>Default Action</h3>

<ul>
<li>terminate(SIGHUP)</li>
<li>terminate+core(SIGABRT/SIGFPE/SIGSEGV/SIGSYS/SIGXCPU/SIGXFSZ)</li>
<li>continue process</li>
<li>stop process</li>
<li>ignore</li>
</ul>


<h3>Slow System Calls</h3>

<ul>
<li>read/write</li>
<li>open</li>
<li>pause</li>
<li>ioctl</li>
<li>some IPC funcitons</li>
<li>the slow system calls will be restart after the signal</li>
</ul>


<h3>Reentrant Functions</h3>

<ul>
<li>文件操作/Socket操作/进程操作系列函数是Reentrant的</li>
<li>malloc/free/标准IO(printf)/errno/使用全局数据结构的函数是非Reentrant的</li>
</ul>


<h3>可重入与线程安全</h3>

<ul>
<li>可重入：有一类重要的线程安全函数，叫做可重入函数，其特点在于它们具有一种属性：当它们被多个线程调用时，不会引用任何共享的数据。与多线程无关，一个函数被多次调用[信号中断]但结果具有可重现性[没有全局数据，不调用非可重入函数]，不会受其他函数影响，输入输出一对一，Linux以_r结尾的函数是可重入的</li>
<li>线程安全：一个函数同时被多个线程调用而得到正确结果[使用互斥锁保证，访问全局数据]，同样的输入可能有不同的输出</li>
<li>可重入是线程安全的子集，</li>
</ul>


<h2>signal/kill</h2>

<ul>
<li>Linux的signal函数内部调用sigaction，不需要每次调用后重置信号行为且是可靠的</li>
<li>kill(pid, sig) pid>0进程号为pid的进程;pid=0同一进程组进程;pid&lt;0进程组为-pid的进程;pid=-1发给除了自身外所有id>1的进程</li>
<li>非root权限的进程只能发信号给同一个session或者同一个用户的进程</li>
<li>多线程程序共享同样的信号处理函数，一个进程中有多个线程则会随机使用一个线程进行处理</li>
</ul>


<h2>alarm&amp;pause</h2>

<ul>
<li>多个信号同时发生会发生类似于栈嵌套执行，即一个信号处理一半中断了处理新收到的信号，处理返回处理栈上一个信号，待所有信号处理完再运行进程的代码</li>
<li>alarm(second)，second秒后产生一个SIGALRM，一个进程只能有一个alarm，一个新的alarm生效前一个则会失效，sleep内部也是使用alarm实现，所以不要混用sleep和alarm</li>
<li>pause函数使进程进入睡眠状态直到捕获任何信号</li>
</ul>


<h2>block sign</h2>

<ul>
<li>sigemptyset/sigfillset/sigaddset/sigdelset/sigismember</li>
<li>sigprocmask Block/Unblock哪些信号</li>
<li>sigpending 返回被Block的信号</li>
</ul>


<h2>11.Threads</h2>

<h3>Thread Identification</h3>

<ul>
<li>pthread_equal/pthread_self</li>
<li>每一个线程拥有自己的stack/register value/signal mask/errno</li>
</ul>


<h3>Thread Creation&amp;Termination</h3>

<ul>
<li>pthread_create</li>
<li>pthread_exit/pthread_cancel</li>
<li>pthread_cleanup_push/pthread_cleanup_pop</li>
<li>pthread_join/pthread_detach</li>
</ul>


<h3>Thread Synchronization</h3>

<h4>Mutex</h4>

<ul>
<li>pthread_mutex_init/pthread_mutex_destroy/PTHREAD_MUTEX_DESTORY</li>
<li>pthread_mutex_lock/pthread_mutex_unlock/pthread_mutex_try_lock</li>
</ul>


<h4>Reader-Writer Locks</h4>

<ul>
<li>pthread_rwlock_init/pthread_rwlock_destory</li>
<li>pthread_rwlock_rdlock/pthread_rwlock_wrlock/pthread_rwlock_unlock</li>
<li>pthread_rwlock_tryrdlock/pthread_rwlock_trywrlock</li>
</ul>


<h4>Condition Variables</h4>

<ul>
<li>pthread_cond_init/pthread_cond_destory</li>
<li>pthread_cond_wait/pthread_cond_timewait</li>
<li>pthread_cond_signal/pthread_cond_broadcast</li>
</ul>


<h2>hange the attribute appear in Chapter 11</h2>

<ul>
<li>pthread_once:某个函数只执行一次，用于单例模式</li>
<li>__thread声明的变量每个线程拥有独立的值</li>
</ul>


<h2>13.Daemon Process</h2>

<h3>Coding Rules</h3>

<ul>
<li>umask(0) 清除不必要的权限位</li>
<li>fork+parent exit</li>
<li>setsid 创建新会话，脱离中断</li>
<li>chdir(/) 当前目录可能重启后不存在(如果是挂载的)</li>
<li>close unneeded file discriptor</li>
<li>open 0/&frac12; to /dev/null 防止读写终端</li>
</ul>


<h3>Error Logging</h3>

<ul>
<li>syslog(level, fmt, &hellip;)</li>
</ul>


<h3>TIP</h3>

<ul>
<li>调用系统函数daemon(int nochdir, int noclose)直接完成该功能</li>
<li>用于服务器端程序</li>
<li>使用基于File的RecordLock来生成单例Daemon</li>
</ul>


<h3>Daemon Conventions</h3>

<ul>
<li>lock file in /var/run/name.pid</li>
<li>config file in /etc/name.conf</li>
<li>auto-start script in /etc/rc<em> or /etc/init.d/</em> or /etc/inittab</li>
<li>use SIGHUP to notify the daemon reload config file</li>
</ul>


<h2>14.Advanced I/O</h2>

<h3>Nonblock I/O</h3>

<ul>
<li>set with open(fd, O_NONBLOCK)</li>
<li>set with fcntl()</li>
</ul>


<h3>Record Lock</h3>

<ul>
<li>支持对一个文件的区域进行锁</li>
</ul>


<h3>STREAMS</h3>

<h3>I/O Multiplexing</h3>

<ul>
<li>select/poll</li>
<li>readv/writev/readn/writen</li>
</ul>


<h3>Memory-Mapped I/O</h3>

<ul>
<li>mmap</li>
</ul>


<h2>15.Interprocess Communication</h2>

<h3>Default IPC</h3>

<h4>Pipes</h4>

<ul>
<li>pipe(field[2])</li>
<li>打开后使用/read/write操作，最后一个使用进程退出会自动关闭</li>
<li>half-duplex</li>
<li>work between process have a common ancestor</li>
<li>is a file discriptor</li>
<li>popen/pclose</li>
</ul>


<h4>FIFOS(named pipes)</h4>

<ul>
<li>mkfifo</li>
<li>打开后使用open/read/write操作</li>
<li>cross process without a common ancester</li>
<li><ul>
<li>is a file discriptor</li>
</ul>
</li>
</ul>


<h4>SIGNAL</h4>

<h3>XSI IPC</h3>

<h4>Message Queue</h4>

<h4>Semaphore</h4>

<h4>Shared Memory</h4>

<h4>Advantage&amp;Disadvantage</h4>

<ul>
<li>XSI IPC是全局的，需要手动关闭</li>
<li>使用full-duplex pipe替换MQ</li>
<li>使用record-lock替换semaphore</li>
<li>使用mmap替换shared memory</li>
</ul>


<h2>16.Network IPC: Sockets</h2>

<h3>TCP Status</h3>

<h4>起始</h4>

<ul>
<li>CLOSED</li>
</ul>


<h4>连接</h4>

<ul>
<li>被动打开: LISTEN/SYN_RCVD</li>
<li>主动打开: SYN_SENT</li>
</ul>


<h4>传输中</h4>

<ul>
<li>ESTABLISHED</li>
</ul>


<h4>断开</h4>

<ul>
<li>主动断开:FIN_WAIT_1/FIN_WAIT_2/CLOSING(同时断开)/TIME_WAIT</li>
<li>被动断开:CLOSE_WAIT/LAST_ACK</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++类型转换笔记]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/07/22/C%2B%2B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%AC%94%E8%AE%B0/"/>
    <updated>2014-07-22T21:19:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/07/22/C++类型转换笔记</id>
    <content type="html"><![CDATA[<h1>C语言默认</h1>

<ul>
<li>int(a)</li>
<li>(int)a</li>
</ul>


<h1>std::static_cast</h1>

<ul>
<li>效果同C语言默认</li>
<li>派生类向上转换为基类（安全）</li>
<li>基类向下转换为派生类（不安全，必须程序员保证）</li>
</ul>


<h1>std::dynamic_cast</h1>

<ul>
<li>基类向下转换为派生类（安全）</li>
<li>引用的话抛出std::bad_cast，指针返回空指针</li>
<li>运行时检查，依赖于虚函数表，基类必须有虚函数，效率比static_cast低</li>
</ul>


<h1>std::reinterpret_cast</h1>

<ul>
<li>把任意一个指针或算术类型转为任意其他指针或算术类型</li>
<li>一般只用于把指针转为int或int转为指针</li>
</ul>


<h1>std::const_cast</h1>

<ul>
<li>用来去掉变量的const/volatile属性</li>
</ul>


<h1>boost::polymorphic_cast</h1>

<ul>
<li>与dynamic_cast类型，但指针和引用转换失败都抛出std::bad_cast</li>
</ul>


<h1>boost::polymorphic_downcast</h1>

<ul>
<li>debug使用dynamic_cast，release使用static_cast</li>
<li>貌似能提高效率，但一般不要使用</li>
</ul>


<h1>boost::numeric_cast</h1>

<ul>
<li>用来防止较大的类型转成较小类型的数值回绕问题和有符号数转为无符号数的符号错误，失败抛出boost::bad_numeric_cast</li>
<li>doulbe转成float如果只是损失小数点精度的话不会抛出异常</li>
<li>sizeof(T)/std::numeric_limits<T>::max()获得类型的大小</li>
</ul>


<h1>boost::lexical_cast</h1>

<ul>
<li>把数值类型转为字符串类型 string a = boost::lexical_cast<string>(123)</li>
<li>把字符串类型转为数值类型 int a = boost::lexical_cast<int>(&ldquo;12&rdquo;)</li>
<li>失败抛出bad_lexical_cast</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mutex&Lock笔记]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/07/22/Mutex%26Lock%E7%AC%94%E8%AE%B0/"/>
    <updated>2014-07-22T21:15:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/07/22/Mutex&Lock笔记</id>
    <content type="html"><![CDATA[<h1>Mutex</h1>

<h2>Eclusive Ownership</h2>

<ul>
<li>mutex，一个简单的mutex只能被锁住一次，假如同一线程试图两次锁定mutex，将会产生死锁。</li>
<li>recursive mutex，一个线程可以多次锁定一个mutex，但必须以同样的次数对mutex进行解锁，否则其他线程将无法锁定该mutex。</li>
<li>shared mutex，多个线程读，单个线程写，lock/shared_lock，使用一个unique_lock和一个shared_lock对一个shared_mutex操作可以实现读写锁</li>
</ul>


<h2>获取锁行为</h2>

<ul>
<li>等待并试图对mutex加锁，直到没有其他线程锁定mutex；</li>
<li>试图对mutex加锁，并立即返回，假如其他线程锁定了mutex；</li>
<li>等待并试图对mutex加锁，直到没有其他线程锁定mutex或者直到规定的时间已过。</li>
</ul>


<h2>分类</h2>

<ul>
<li>mutex(try_mutex)</li>
<li>timed_mutex</li>
<li>recursive_mutex</li>
<li>recursive_timed_mutex</li>
<li>shared_mutex</li>
</ul>


<h1>Lock</h1>

<h2>分类</h2>

<ul>
<li>lock_guard 利用RAII的最简单实现</li>
<li>unique_lock 在lock_guard的基础上提供了try_lock()/timed_lock</li>
<li>shared_lock 读写锁中的读锁</li>
<li>upgrade_lock  未明</li>
</ul>


<h1>Reference</h1>

<ul>
<li><a href="http://www.boost.org/doc/libs/1_41_0/doc/html/thread/synchronization.html">Boost Synchronization</a></li>
<li><a href="http://zh.highscore.de/cpp/boost/multithreading.html">Boost多线程</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ Tip]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/07/22/cpp-tips/"/>
    <updated>2014-07-22T21:12:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/07/22/cpp-tips</id>
    <content type="html"><![CDATA[<h1>C++</h1>

<ul>
<li>虚函数是为了用基类指针能调用子类函数，虚函数必须有实现</li>
<li>纯虚函数是为了使类不能被实例化定义接口。纯虚函数只有声明</li>
<li>基类向下转型成派生类</li>
<li>定义构造函数、复制构造函数、或赋值操作符三个中的任意一个,你也需要定义另外两个</li>
<li>使用class a:private boost::non copyable</li>
<li>泛型是水平的，把各种不同的互相没有什么关系的类型应用于同一种算法；继承是垂直的，从抽象到具体，子类和父类是有关系的。</li>
</ul>


<h1>Linux</h1>

<ul>
<li>一个线程结束时要通过pthread_join或者pthread_detach(pthread_self())来释放8K左右的堆栈和线程描述符</li>
<li>interrupt只有在代码执行到wait/join/sleep这三种检查点的时候才会中断</li>
</ul>


<h1>Others</h1>

<ul>
<li>聚合：离散聚合/累积聚合/滑动聚合</li>
<li>旋转：开放架构(id/attr/val)与Cube</li>
<li>UnitTest:Setup/Exercice/Verify/Teardown</li>
<li>gtest事件：Enviroment(SetUp/TearDown)/TestSuite(SetUp/TearDownTestCase)/TestCase(SetUp/TearDown)</li>
</ul>


<h2>Redis数据类型</h2>

<ul>
<li>String: set/get/desc/incr/mget</li>
<li>List: lpush/rpush/lpop/rpop/lrange</li>
<li>Hash: hget/hset/hgetall/hmset/hmget</li>
<li>Set: sadd/spop/smembers/sunion</li>
<li>Sorted Set: zadd/zrem/zrange</li>
<li>Sorted Set由HashSet(正排，key:score)+SkipList构成(倒排, score:key，类似平衡树，查找复杂度O(logn))</li>
</ul>


<h2>CouchBase数据类型</h2>

<ul>
<li>redis提供各种数据结构但CouchBase都是JSON</li>
<li>bucket 相当于数据库的db+table</li>
<li>set/add/replace</li>
<li>cas(key, oldval, newval) 替换为新值的时候值必须为旧值，保证数据一致性</li>
<li>get/delete/touch</li>
<li>append/prepend/incr/decr</li>
<li>lock(key, ttl)/unlock</li>
<li>with pipeline可以实现get_multi/set_multi等的批处理效果</li>
<li>通过MapReduce实现条件查询[View必须预先定义好，一个DesignDocument包括多个View], map函数中通过emit返回符合条件的数据进行reduce</li>
<li>开发模式增量数据会自动进行MapRedure加到View索引中，开发模式则不会</li>
</ul>


<h2>CAP</h2>

<ul>
<li>Consistency</li>
<li>Availability[快速获得数据]</li>
<li>Tolerance of network Partition[分布式]</li>
<li>一个分布式系统只能满足其中两个，不可能全部满足</li>
<li>CA:传统数据库</li>
<li>AP:K-V数据库</li>
</ul>


<h2>BASE</h2>

<ul>
<li>Base Availble</li>
<li>Soft-state(无连接)</li>
<li>Eventual Consistency</li>
</ul>


<h2>死锁形成条件(一个不符合则不会死锁)</h2>

<ul>
<li>资源互斥性[A占有B就不能占有]</li>
<li>资源不可剥夺</li>
<li>请求且保持[等待一个资源的时候不释放当前占有的资源]</li>
<li>循环等待</li>
</ul>


<h2>TCP/IP</h2>

<p>ESTABLISHED 表示正在通信，TIME_WAIT 表示主动关闭，CLOSE_WAIT 表示被动关闭。
ps -fu wuyixiang 查找我的进程
cat /proc/[pid]/status 查看pid的进程占用的内存大小(当前，峰值)</p>
]]></content>
  </entry>
  
</feed>
