<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[乌衣巷]]></title>
  <link href="http://CodePeasant.github.io/atom.xml" rel="self"/>
  <link href="http://CodePeasant.github.io/"/>
  <updated>2014-12-18T15:23:49+08:00</updated>
  <id>http://CodePeasant.github.io/</id>
  <author>
    <name><![CDATA[吴逸翔]]></name>
    <email><![CDATA[1032197148@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[数据挖掘导论笔记]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/12/18/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0/"/>
    <updated>2014-12-18T11:25:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/12/18/数据挖掘导论笔记</id>
    <content type="html"><![CDATA[<h1>数据挖掘导论笔记</h1>

<h2>1.绪论&amp;2.数据</h2>

<h3>定义</h3>

<ul>
<li>数据挖掘与信息检索/统计的区别</li>
<li>数据挖掘[Data Mining]:从数据库的大量数据中揭示出隐含的、先前未知的并有潜在价值的信息的非平凡过程，又称为KDD[Knowledege Discovery in Database]</li>
</ul>


<h3>数据挖掘任务</h3>

<ul>
<li>预测建模[离散:分类; 连续:回归]</li>
<li>聚类分析</li>
<li>关联分析</li>
<li>异常检测</li>
</ul>


<h3>属性类型</h3>

<ul>
<li>Normal: 标称(==, !=),众数</li>
<li>Ordinal: 序数(&lt;, >),中位数</li>
<li>Interval: 区间(+, &ndash;),算术平均数</li>
<li>Ratio: 比率(*, /),几何平均数</li>
</ul>


<h3>数据质量</h3>

<ul>
<li>Precision: 精度，标准差</li>
<li>Bias: 偏倚，均值与实际值的差</li>
</ul>


<h3>数据预处理</h3>

<ul>
<li>聚集</li>
<li>抽样</li>
<li>维归约</li>
<li>特征子集选择</li>
<li>特征创建</li>
<li>离散化和二元化</li>
<li>变量变换（规范化，映射）</li>
</ul>


<h3>相似度</h3>

<ul>
<li>Minkowski Distance(n=1,街区距离;n=2,欧几里得距离)</li>
<li>Simple Matching Coefficient: SMC=(f11+f00)/(f10+f01+f11+f00)</li>
<li>Jaccard Coefficient: J=f11/(f10+f01+f11+f00)</li>
<li>Cosine Similarity: cos(x,y)=x<em>y/(|x|</em>|y|)</li>
<li>Pearson&rsquo;s Correlation: corr(x,y)=covariance(x,y)/(standard_deviation(x)*standard_deviation(y))</li>
</ul>


<h2>3.探索数据</h2>

<h3>汇总统计</h3>

<ul>
<li>mode(众数)/median(中位数)/mean(均值)</li>
<li>range(极差)/variance(方差)/standard deviation(标准差)</li>
<li>covariance matrix(协方差矩阵)</li>
</ul>


<h3>可视化</h3>

<ul>
<li>stem and leaf plot(茎叶图)</li>
<li>histogram(直方图)</li>
<li>box plot(盒状图)</li>
<li>pie chart</li>
<li>contour plot(等高线图)</li>
</ul>


<h3>多维数据</h3>

<ul>
<li>data cube(数据立方体): 数据的多维表示，连同可能的总和（聚集/维归约</li>
<li>pivoting(转轴): 除了两个维之外所有维的聚集</li>
<li>slicing(切片): 对一个或多个维指定值进行聚集</li>
<li>dicing(切块): 对一个或多个维指定区间进行聚集</li>
<li>roll up(上卷): 聚集</li>
<li>drill down(下钻): 分解</li>
</ul>


<h2>4.分类: 使用决策树</h2>

<h3>预备知识</h3>

<ul>
<li>classification(分类): 通过学习得到一个目标函数/分类模型(target function)，把每个属性集x映射到一个预先定义的类标号y</li>
<li>描述性建模/预测性建模</li>
<li>训练集(training set)/检验集(test set)</li>
<li>混淆矩阵(confusion matrix)</li>
</ul>


<h3>决策树终止条件</h3>

<ul>
<li>没有符合条件的记录</li>
<li>所有记录都有相同的类标号</li>
</ul>


<h3>划分度量</h3>

<ul>
<li>Entropy(t) = -sum(p(i|t)*log2(p(i|t)))</li>
<li>Gini(t) = 1-sum(p(i|t)<sup>2</sup>)</li>
<li>Classification errorz(t) = 1-max(p(i|t))</li>
<li>信息增益Δinfo=I(parent) &ndash; sum(p(son)*I(son))</li>
<li>增益率Gain Ratio = Δinfo/Split Info, Split Info = -sum(p(v)*log2(p(v))</li>
<li>数据碎片：某些叶节点记录太少，不能做出具有统计意义的判决</li>
</ul>


<h3>误差</h3>

<ul>
<li>training error(训练误差)</li>
<li>generalization error(泛化误差)</li>
</ul>


<h3>拟合</h3>

<ul>
<li>model underfitting: 模型拟合不足，一开始模型没有学习到数据的真实结构，在训练集和检验集上的误差都很大</li>
<li>model overfitting: 模型过度拟合，一旦树的规模变的太大，虽然训练误差还在降低，但检验误差会开始增大</li>
<li>Occam&rsquo;s razor: 奥卡姆剃刀，给定两个具有相同泛化误差的模型，较简单的模型比较复杂的模型更可取</li>
<li>Minimum Description Length(MDL): Cost(Data, Model) = Cost(Model) + Cost(Data|Model)</li>
<li>解决拟合的方法：(1)先剪枝，提前终止；(2)后剪枝，子树提升/子树替换</li>
</ul>


<h3>分类器评估</h3>

<ul>
<li>Holdout(保持方法): 一部分划为训练集，一部分划为检验集</li>
<li>Random Subsampling(随机二次抽样): 进行多次保持方法</li>
<li>k-Cross-Validation(k折交叉验证): 把所有数据分为k个大小相同的子集，1份用于检验，其他的用于训练</li>
<li>置信区间: 综合考虑样本数和准确率</li>
</ul>


<h2>5.分类: 其他技术</h2>

<h3>分类器分类</h3>

<ul>
<li>积极学习方法(eager learner): 从训练数据中建立输入属性到类标号的映射模型</li>
<li>消极学习方法(lazy learner): 推迟对训练数据的建模直到进行分类测试时才进行</li>
</ul>


<h3>基于规则的分类器</h3>

<ul>
<li>规则分类器使用if&hellip;then&hellip;进行分类，但所有的规则加起来并不一定能覆盖所有的记录</li>
</ul>


<h3>最近邻分类器(K-Nearest-Neighbor)</h3>

<ul>
<li>使用k个与待分类点z最近距离的数据点采用多数表决方案来判定类标号</li>
<li>k值太小易受噪声影响产生过分拟合，太大会忽视局部信息错误分类</li>
<li>一个改进是对使用与距离平方成反比的加权</li>
</ul>


<h3>贝叶斯分类器(Beyesian)</h3>

<ul>
<li>X为属性集，Y为类标号，P(Y|X)称为Y的后验概率，P(Y)称为Y的先验概率，P(X|Y)称为类条件概率，则P(Y|X) = P(X|Y)*P(Y)/P(X)</li>
<li>对于某些属性样本缺失和样本数量较少，使用m-estimate比较好</li>
<li>朴素贝叶斯(Naive Beyesian)分类器要求各属性条件独立，贝叶斯信念网络(Beyesian Belief Networks)不要求</li>
</ul>


<h3>人工神经网络(Artifical Neural Network)</h3>

<ul>
<li>人的大脑通过在同个脉冲下反复刺激改变神经元之间的连接强度，故使用激活函数y = sign(w*x) w为连接强度的权重向量，x为输入属性向量</li>
<li>每次更新采用w[i+1,k] = w[i,k] + λ<em>(y-^y)</em>x[i,k]来迭代更新权重，λ称为学习率，在0~1之间，y为预测值，<sup>y</sup>为实际值</li>
<li>感知器模型(Perceptron)与多层人工神经网络</li>
</ul>


<h3>支持向量机(Support Vector Machine)</h3>

<ul>
<li>决策边界:理想状况下把两种类标号恰好分布在决策边界的两侧（也允许存在噪声），距离两类类标号最小距离最大的决策边界称为最大边缘超平面（maximal margin hyperplane）</li>
<li>线性支持向量机</li>
<li>非线性支持向量机通过属性变换和核技术转换成线性支持向量机问题</li>
</ul>


<h3>组合方法</h3>

<ul>
<li>装袋:bagging，均匀概率从数据集中重复有放回抽样的方法</li>
<li>提升:通过迭代聚集到存在分类困难的样本上，AdaBoost</li>
<li>随机森林: Random Forest</li>
</ul>


<h3>不平衡类问题</h3>

<ul>
<li>不平衡类问题：两种类标号的记录比例悬殊，如信用卡欺诈检测</li>
<li>混淆矩阵：Confusing Matrix, TP/FP/TN/FN</li>
<li>TPR = TP/(TP+FN)，被预测为正的正样本比例，也称为recall</li>
<li>FNR = FN/(FN+TP)，被预测为负的正样本比例</li>
<li>FPR = FP/(FP+TN)，被预测为正的负样本比例</li>
<li><p>TNR = TN/(TN+FP)，被预测为负的负样本比例</p></li>
<li><p>召回率：recall = TP/(TP+FN)</p></li>
<li>准确率：precison = TP/(TP+FP)</li>
<li>召回率+准确率的综合度量: F1 = 2/(1/r+1/p) = 2rp/(r+p)</li>
<li>ROC曲线：Receiver Operating Characteristic，显示TPR从0到1的过程中FPR的变化</li>
</ul>


<h2>6.关联分析</h2>

<ul>
<li>关联规则: X->Y</li>
<li>support: 支持度，数据集X∩Y在所有的事务中出现的频繁程度 X∩Y / All</li>
<li>confidenct: 置信度，Y在包含X的事务中出现的频繁程度 X∩Y / X</li>
<li>关联规则分析算法分两步：</li>
<li>产生满足最小支持度的频繁项集(frequent itemset)</li>
<li>从频繁项集中提取所有高置信度的规则(strong rule)</li>
<li>Apriori原理：先验原理，一个项集是频繁的，则他的所有的子集也都是频繁的，根据该原理是用基于支持度的剪枝，提出Apriori算法</li>
<li>Apriori算法：每次产生候选k-项集，然后根据支持度进行剪枝，再产生新的(k+1)-项集，直到没有新的频繁项集产生</li>
<li>基于支持度的剪枝是单调性的，但基于置信度的剪枝不具备单调性</li>
</ul>


<h2>6.聚类分析：基本概念和算法</h2>

<ul>
<li>k均值算法：(0)开始随机选择k个质心;(1)把每个点加到最近的质心的簇中;(2)重新计算每个簇的质心，重复(1)</li>
<li>初始簇的选择很重要，可以多次随机选择并计算最终结果的SSE来找到一个较优解</li>
<li>k均值算法适合于球形同密度分布</li>
<li>评估：凝聚度（同一个簇的点到质心的距离之和）和分离度（不同簇的质心距离）</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[线性代数读书笔记]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/12/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <updated>2014-12-02T21:45:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/12/02/线性代数读书笔记</id>
    <content type="html"><![CDATA[<h1>线性代数读书笔记</h1>

<h2>1.行列式</h2>

<ul>
<li>D= |a11 a12|=a11*a22-a21*a12称为二阶行列式
 |a21 a22|</li>
<li>n阶行列式D：n阶行列式由n行n列组成，供n<sup>2</sup>个元素</li>
<li>余子式Mij：划去第i行第j列剩余的n-1阶行列式称为元素aij的余子式</li>
<li>代数余子式Aij：(-1)<sup>i+j</sup>*Mij称为元素aij的代数余子式</li>
<li>高阶行列式的展开降阶：D=a1j*A1j+&hellip;+anj*Anj</li>
<li>行列式与其转置行列式值相等，即D=DT</li>
<li>行列式的行与列地位相同，可以按行展开也可以按列展开</li>
<li>kD等于对某一行或者某一列乘以k</li>
<li>行列式某一列为0则行列式为0</li>
<li>行列式交换两行，则值取反号</li>
<li>行列式两行相同或成比例则值为0</li>
<li>行列式把某一行的元素的k倍加到另一行上，其值不变</li>
<li>Cramer法则，xj=Dj/D 其中Dj是用常数列替换D的第j列</li>
</ul>


<h2>2.矩阵</h2>

<ul>
<li>m行n列的矩阵称为m*n矩阵</li>
<li>若两矩阵行列数分别相等，则称它们是同型矩阵</li>
<li>零矩阵：所有元素为0</li>
<li>n阶方阵：n*n矩阵</li>
<li>单位矩阵：主对角线元素为1，其他元素为0的n阶方阵，记为I</li>
<li>对角矩阵/上(下)三角形矩阵/行矩阵(行向量)/列矩阵(列向量)</li>
<li>矩阵的加法/数量乘积/</li>
<li>矩阵乘法不满足交换律和消除律，但满足分配律和结合律</li>
<li>转置矩阵:ATT=A,(A+B)T = AT+BT, (AB)T = BTAT</li>
<li>对称矩阵:AT=A，反称矩阵:AT=-A</li>
<li>可逆矩阵:A为n阶方阵，A(-1) * A = A * A(-1)= I，则称A为可逆矩阵/满秩矩阵/非奇异矩阵</li>
<li>伴随矩阵A*:A的每个元素aij都替换成其代数余子式Aij组成的矩阵</li>
<li>A(-1) = A*/|A|, A*是A的伴随矩阵，|A|是A的行列式值</li>
<li><p>n阶方阵可逆的充要条件是方阵的行列式值不为0</p></li>
<li><p>矩阵的初等变换</p></li>
<li>互换矩阵的第i行(列)与第j行(列)的位置，记为ri&lt;&ndash;>rj(ci&lt;&ndash;>cj)</li>
<li>用一个非零常数k乘矩阵的第i行(列)，记为kri(kci)</li>
<li><p>将矩阵的第j行(列)的k倍加到第i行(列)上，记为ri+k*rj (记为ci+k*cj)</p></li>
<li><p>矩阵的行初等变换与列初等变换统称为矩阵的初等变换，行初等变换可以把矩阵变成行阶梯形矩阵和行标准形，进一步加上列初等变换可以变成矩阵的标准形</p></li>
<li>对单位矩阵I施行一次初等变换得到的矩阵称为初等矩阵，包括：Rij, Ri(k), Ri+j(k)</li>
<li>对矩阵A施行一次行初等变换，相当于用相应的初等矩阵左乘A，施行一次列初等变换相当于用相应的初等矩阵右乘A</li>
<li>初等变换求逆法</li>
<li>从一个m行n列的矩阵A中任意抽取k行k列按原来的相对位置构成的行列式称为A的一个k阶子式</li>
<li>矩阵A中不等于0的子式的最大阶数称为矩阵A的秩，记为r(A)，故可逆矩阵又称为满秩矩阵</li>
<li>初等变换不改变矩阵的秩，故用初等变换在变换到行阶梯形乃至标准形的过程中可以看出矩阵的秩</li>
</ul>


<h2>5.相似矩阵</h2>

<ul>
<li>AX=λX，则称数λ为矩阵A的特征值，非零向量X为矩阵A对应特征值λ的特征向量* f(λ)=|λI-A|称为n阶矩阵A的特征多项式，f(λ)=0在复数域内有n个解，即A的n个特征值</li>
<li>对于n阶方阵A、B，若有可逆的n阶方阵P，使得P(-1)*A*P=B，则称A与B相似，记为A~B，可逆矩阵P称为相似变换矩阵</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hadoop权威指南笔记]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/11/28/Hadoop%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/"/>
    <updated>2014-11-28T19:32:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/11/28/Hadoop权威指南笔记</id>
    <content type="html"><![CDATA[<h1>Hadoop权威指南笔记</h1>

<h2>1.&amp;2.关于MapReduce</h2>

<ul>
<li>数据本地化是MapReduce的核心特征，hadoop通过显式网络拓扑结构在存储数据附近的机器上进行运算任务，避免把数据复制来复制去耗尽网络带宽</li>
<li>把数据从Mapper传给Reducer称为Shuffle</li>
</ul>


<h2>3.HDFS</h2>

<ul>
<li>namenode负责维护所有文件和目录的文件树，datanode负责存储实际的数据块* HDFS提供了POSIX文件接口，通过操作url hdfs://path可以像操作本地文件一样操作文件，并实现本地和hdfs文件的互传</li>
<li>通过FUSE(Filesystem in Userspace)可以把hdfs挂载到unix系统上</li>
<li>HDFS默认提供Java API访问，其他语言要使用thrift</li>
<li>HDFS的写操作只有三个datanode都写成功了才会返回，如果有一个写失败了则会删除该节点并新建一个节点</li>
<li>每个块的元数据都会存储在namenode的内存中，因此HDFS存储小文件的效率很低</li>
</ul>


<h2>4.Hadoop I/O</h2>

<ul>
<li>数据完整性用CRC32的checksum</li>
<li>Hadoop会自动识别被压缩了的文件并进行解压缩，对于不可切分的压缩格式如gzip/LZO/DEFLATE无法启动并行处理，可以使用可切分的bz2</li>
<li>通过Writable/Readble接口实现序列号/反序列号</li>
<li>序列化/RPC框架: Avro/Thrfit/ProtoBuf</li>
<li>基于文件的数据结构: SequenceFile/MapFile</li>
</ul>


<h2>6.MapReduce工作机制</h2>

<ul>
<li>4大组件: client/jobtracker/tasktracker/HDFS</li>
<li>调度算法:FIFO/Fair Scheduler(支持抢占)</li>
</ul>


<h2>9.构建Hadoop集群</h2>

<ul>
<li>服务器类型: namenode/datanode/jobtracker/tasktracker</li>
<li>使用Kerbros来实现访问控制</li>
</ul>


<h2>12.Hive</h2>

<ul>
<li>使用类似SQL的语法来运行MapReduce查询HDFS，用于数据仓库的离线数据分析</li>
</ul>


<h2>13.HBase</h2>

<ul>
<li>列存储，类似于key-value数据库，提供良好的扩展性和硬盘存储，可以存储几个T的数据</li>
</ul>


<h2>14.Zookeeper</h2>

<ul>
<li>配置管理/锁服务</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective C++读书笔记]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/11/27/Effective+C%2B%2B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <updated>2014-11-27T23:34:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/11/27/Effective C++读书笔记</id>
    <content type="html"><![CDATA[<h1>Effective C++读书笔记</h1>

<h2>1.让自己习惯C++</h2>

<ul>
<li>声明与定义: 对象(包括原生)/函数/类/模板</li>
<li>C++范型: 过程/面向对象/范型/元编程(Boost.MPL,利用编译期生成)</li>
<li>使用const/enum/inline替换#define</li>
<li>类的const函数返回值如果是成员变量的引用也设为const防止改变返回</li>
<li>函数参数和返回值使用传const引用提高效率</li>
<li>mutable的成员变量在类的const函数中也能被修改</li>
<li>类可以对成员函数进行const重载，当一个对象是const的时候调用的是const函数，否则调用non-const函数</li>
<li>对于全局变量使用包装函数(原生类型)或者单件模式(类)</li>
</ul>


<h2>2.构造/析构/赋值函数</h2>

<ul>
<li>default: construct/destruct/copy/copy assignment</li>
<li>copy assignment并不生成新对象，只是单纯地赋值，返回*this</li>
<li>class base:private boost::noncopyable, noncopyable把construct/destruct设为protected，把copy/copy assignment设为private并且只有声明无实现</li>
<li>多态基类必须带有虚析构函数，STL/string等类没有定义虚析构函数不适合继承</li>
<li>析构函数中应当捕获异常让其不再向上传播，选择不处理或者abort退出</li>
<li>构造和析构函数中不要调用virtual函数，必须调用的共同代码改为non-virtual或者采用两段式构造</li>
<li>operator=返回一个reference to *this以支持链式操作</li>
<li>operator=对指针进行new/delete需要注意自我赋值，采用identity test或者采用一个temp变量来具备异常安全性(或者是整体的copy and swap)</li>
<li>copy函数(当前对象还没构造)，copy assignment(当前对象已经构造)，故两个函数间不能相互调用，对于相同的代码应当抽离作为一个init函数被这两个函数调用</li>
<li>copy/copy assignment函数[合称为copying函数]应当复制所有成员变量（新增变量时需要修改copying函数），调用所有base class的copying函数</li>
</ul>


<h2>3.资源管理</h2>

<ul>
<li>采用RAII来管理资源：获得资源后立刻放入管理对象，管理对象运用析构函数确保资源被释放</li>
<li>shared_ptr析构时调用的是delete，故不能用于管理数组，数组使用vector</li>
<li>auto_ptr只能有一个指向对象，复制时原来的auto_ptr会变成null，shared_ptr拥有正确的复制行为，可以被放进STL中</li>
<li>一个RAII对象默认不应该被复制，需要复制时对管理的资源采用RCSP管理</li>
<li>RAII对象显式提供一个get函数提供内部资源的访问</li>
<li>share_ptr<A> a(new A());应当写成独立一行防止失败造成内存泄露</li>
</ul>


<h2>4.设计与声明</h2>

<ul>
<li>让接口容易被正确使用，不易被误用</li>
<li>返回一个绑定了删除器的share_ptr比返回原始指针好</li>
<li>使用pass-by-reference-to-const替换pass-by-value，提高传递效率同时防止派生类被slice成基类导致虚函数调用错误</li>
<li>返回值一般返回value而不是reference/pointer，返回reference可能是返回了一个局部变量的reference</li>
<li>成员变量声明为private，protected会影响派生类，并不比public安全多少</li>
<li>使用non-member non-friend函数代替member函数，不访问private变量的函数都不应该写成member函数，减少member函数的数量有利于类的封装和弹性，这类函数称为便利函数</li>
<li>把便利函数和原生类组织在同一个namespace下，把不同功能的便利函数分布到不同的头文件中但共享同一个namespace</li>
<li>默认的swap函数要求类型T支持copying操作</li>
<li>默认的swap效率不足时为自己的class添加一个swap的member函数，再在同一命名空间中添加一个non-member的swap函数调用类的swap函数</li>
</ul>


<h2>5.实现</h2>

<ul>
<li>尽可能延后变量的定义，一个循环中使用的变量除非对于效率很敏感，一般写在循环的作用域中而不是之外</li>
<li>尽可能少用转型，用的时候也把它显式声明出来（如static_cast），不要隐式转型</li>
<li>尽可能不要返回类的成员变量的reference/pointer（即使是const），防止dangling handles</li>
<li>异常安全的三种渐进保证：(1)保证抛出异常数据不遭到破坏；(2)保证函数要么完全成功要么抛出异常回到调用前的状态[使用copy and swap技术，所有操作都在copy的对象上操作，操作完再swap]；(3)函数不抛出异常</li>
<li>运行期的virtual函数无法进行编译期的inline</li>
<li>使用声明式类代替定义式类减少编译依存性，提高编译速度，使用Handle Class[pImpl]或者Interface Class[pure virtual class]技术来完成该目的
b

<h2>6.继承与面向对象设计</h2></li>
<li>public继承意味着is-a关系，Liskov Substitution Principle</li>
<li>private成员意味着has-a关系</li>
<li>派生类定义的函数会覆盖所有基类同样名字的函数，即使基类对该名字进行了参数重载，为了避免该问题需要在派生类中使用using Base::func引入名字</li>
<li>pure-virtual function只提供一个接口的继承;impure-virtual function提供一个接口和一份缺省实现[多态];non-virtual function提供一个接口和一份强制实现[覆盖]</li>
<li>模板模式:使用一个public的函数来调用各个private的virtual子函数实现模板模式</li>
<li>策略模式:在构造函数中传入策略函数的指针/boost::function对象并保存起来</li>
<li>不要覆盖继承而来的non-virtual函数，防止在不同指针类型上表现不一</li>
<li>virtual函数的缺省值是静态绑定，virtual函数是动态绑定，因此不要修改virtual函数的缺省参数的值，否则会导致用子类的virtual函数但参数却还是基类的默认值</li>
<li>多重继承应该只用于public继承一个interface和private继承一个协助实现的类</li>
</ul>


<h2>7.模板与泛型编程</h2>

<ul>
<li>继承：基于函数签名的显式接口&amp;运行期多态</li>
<li>模板：基于有效表达式的隐式接口&amp;编译期多态</li>
<li>typename与class可以互换，但嵌套模板类型前必须加上typename，如typename T::type a;</li>
<li>template会导致代码膨胀，和inline一样</li>
<li>模板的特化:template&lt;>class A<Class B></li>
<li>数字模板化:template<class T, size_t n></li>
<li>派生类模板要调用基类模板方法必须使用this->func()</li>
<li>traits使用typedef+template/template特化+函数重载实现</li>
<li>typeid发生在运行期，函数重载发生在编译期</li>
<li>Template Metaprogramming(模板元编程)将工作从运行期移往编译期，便于较早发现错误和更高的执行效率</li>
<li>TMP属于函数式编程语言，通过递归实现循环</li>
</ul>


<h2>8.定制new和delete</h2>

<ul>
<li>set_new_handle提供一个全局的处理new异常的函数，通过RAII可以为每个类订制各自的set_new_handler</li>
<li>static void* Base::operator new(size_t size) throw(std::bad_alloc);</li>
<li>static void Base::operator delete(void *rawMemory, size_t size) throw();</li>
<li>placement new/delete可以在指定的指针地址上分配内存，必须结对出现：ClassA *a = new(buf) ClassA;</li>
</ul>


<h2>9.杂项</h2>

<ul>
<li>不要忽视编译器警告</li>
<li>熟悉STL/tr1/boost</li>
</ul>


<h3>STL</h3>

<ul>
<li>container: vector/string/map</li>
<li>container adapter: stack/priority_queue</li>
<li>iterator</li>
<li>algorithm: find/sort/transform</li>
<li>function object: less/greater</li>
<li>function object adapter: mem_fun/notl</li>
</ul>


<h3>tr1</h3>

<ul>
<li>smart pointers: shared_ptr/weak_ptr</li>
<li>function/bind</li>
<li>hash tables: unordered_set/unordered_multiset/unordered_map/unordered_multimap</li>
<li>regular exporess</li>
<li>tuple/array/mem_fn/reference_wrapper</li>
<li>math function</li>
<li>type traits/result_of</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[概率论与数理统计笔记]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/11/20/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%AC%94%E8%AE%B0/"/>
    <updated>2014-11-20T21:34:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/11/20/概率论与数理统计笔记</id>
    <content type="html"><![CDATA[<h1>概率论与数理统计笔记</h1>

<h2>1.随机事件与概率</h2>

<h3>随机试验</h3>

<ul>
<li>可在相同条件下重复</li>
<li>每次试验可出现不同结果，试验之前不能确定是哪种结果</li>
<li>试验之前可以知道所有可能的结果</li>
</ul>


<h3>随机事件</h3>

<ul>
<li>随机试验的每一个可能的结果称为一个随机事件，简称事件</li>
<li>事件分为基本事件和复合事件</li>
<li>必然事件: Ω</li>
<li>不可能事件: Ø</li>
<li>A∩B = ∅，则A与B为互斥事件</li>
<li>A∩B = ∅且A∪B = Ω，则A与B为对立事件/互为逆事件，B = Ã</li>
</ul>


<h3>概率</h3>

<ul>
<li>非负性，0&lt;=P(A)&lt;=1</li>
<li>规范性，P(Ω)=1</li>
<li>可列可加性，所有互斥事件的概率可以叠加</li>
</ul>


<h3>古典概型</h3>

<ul>
<li>有限性，基本事件总数有限</li>
<li>等可能性，每个基本事件出现的可能性相同</li>
</ul>


<h3>超几何分布</h3>

<p>一批产品有M件正品，N件次品，从中取n件，有k件次品的概率:
P(A)= C[k,N]*C[n-k,M]/C[n,M+N]</p>

<h3>几何概型</h3>

<ul>
<li>无限性，使用面积来描述</li>
<li>等可能性</li>
</ul>


<h3>条件概率</h3>

<ul>
<li>条件概率公式: P(AB) = P(B) * P(A|B)</li>
<li>全概率公式: P(B) = sum(P(B|Ai)*P(Ai))</li>
<li>Ai为样本空间的一个划分，Bj为事件，则A->B:先验概率，B->A:后验概率</li>
<li>后验概率使用贝叶斯公式解决: P(Ai|Bj) = P(Bj|Ai)<em>P(Ai)/sum(P(Bj|Ai)</em>P(Ai))</li>
<li>P(AB) = P(A)*P(B)或P(B) = P(B|A)，则事件AB互相独立</li>
</ul>


<h2>2.随机变量及其分布</h2>

<ul>
<li>随机变量: E为随机试验，Ω={w}为其样本空间，对于任意w，都有唯一实数X(w)与之对应，则称X(w)为随机变量</li>
<li>分布函数: F(x) = P(X&lt;=x), F(-∞)=0, F(+∞)=1</li>
</ul>


<h3>离散型随机变量</h3>

<h4>两点分布/(0-1)分布</h4>

<ul>
<li>P(0) = 1-p, P(1) = p, 则称X服从两点分布，X~(0-1)</li>
</ul>


<h4>二项分布/B(n,p)</h4>

<ul>
<li>一次试验只有两种可能的结果的试验称为伯努利试验</li>
<li>P(X=k) = C[n,k]<em>p<sup>k</sup></em>(1-p)<sup>n-k</sup>，X~B(n,k)</li>
<li>最可能出现次数: (n+1)*p</li>
<li>当n>=20, p&lt;=0.05时，二项分布近似于泊松分布，且λ=np</li>
</ul>


<h4>泊松分布/P(λ)</h4>

<ul>
<li>P(X=k) = λ<sup>k</sup>*e<sup>-λ</sup>/k!, X~P(λ)</li>
<li>λ是泊松分布的均值，也是方差，用来描述单位时间内随机事件的平均发生率</li>
</ul>


<h4>几何分布/G(p)</h4>

<ul>
<li>P(X=k) = (1-p)<sup>k-1</sup>*p</li>
<li>无穷次伯努利试验中事件A首次发生的概率</li>
</ul>


<h3>连续型随机变量</h3>

<ul>
<li>F(x)为概率分布函数，f(x)为概率密度函数，F(x)是f(x)的积</li>
</ul>


<h4>均匀分布/U[a,b]</h4>

<ul>
<li>f(x)=1/(b-a), F(x) = (x-a)/(b-a)</li>
</ul>


<h4>指数分布/E(λ)</h4>

<ul>
<li>f(x)=λ*e<sup>-λx</sup>, F(x)=1-e<sup>-λx</sup></li>
<li>指数分布是一段时间内发生故障的概率上的连续，泊松分布是故障发生次数的离散，都用于描述泊松过程</li>
</ul>


<h4>正态分布/N(μ,σ)</h4>

<ul>
<li>f(x) = e^[&ndash;(x-μ)<sup>2</sup>/(2σ<sup>2</sup>]/[σ*(2π)<sup>&frac12;</sup>]</li>
<li>期望/众数为μ, 标准差为σ，最大值为σ*(2π)<sup>&frac12;</sup>，当μ=σ<sup>2</sup>且μ->∞时变成泊松分布</li>
</ul>


<h2>4.数字特征</h2>

<h3>数学期望</h3>

<ul>
<li>EX: sum(xi*pi), 简称期望/均值</li>
<li>X~(0-1), EX=p</li>
<li>X~B(n,p), EX=np</li>
<li>X~P(λ), EX=λ</li>
<li>X~G(p), EX=1/p</li>
<li>X~U[a,b], EX=(a+b)/2</li>
<li>X~E(λ), EX=1/λ</li>
<li>X~N(μ,σ<sup>2</sup>), EX=μ</li>
</ul>


<h3>方差</h3>

<ul>
<li>DX=E((X-EX)<sup>2</sup>)=E(X<sup>2</sup>)&ndash;(EX)<sup>2</sup>, 称为方差</li>
<li>X~(0-1), DX=pq</li>
<li>X~B(n,p), DX=npq</li>
<li>X~P(λ), DX=λ</li>
<li>X~G(λ), DX=q/(p<sup>2</sup>)</li>
<li>X~U[a,b], DX=[(b-a)<sup>2</sup>]/12</li>
<li>X~E(λ), DX= 1/(λ<sup>2</sup>)</li>
<li>X~N(μ,σ<sup>2</sup>), DX=σ<sup>2</sup></li>
</ul>


<h3>协方差</h3>

<ul>
<li>协方差:(X,Y)为二维随机变量，Cov(X,Y)=E((X-EX)*(Y-EY))=E(XY)-EXEY，用于衡量X,Y之间的线性关系，当Cov(X,Y)=0时X,Y独立[但可能有非线性关系]</li>
<li>相关系数:ρ(X,Y)=Cov(X,Y)/[(DX*DY)<sup>2</sup>]，标准化后的协方差；|1|为完全正/负相关，0为不相关</li>
<li>协方差矩阵:对于X,Y为n元向量，则有n*n的协方差矩阵，第i行j列的元素为e(i,j)=Cov(Xi,Yj)</li>
</ul>


<h3>中心极限定理</h3>

<ul>
<li>大量相互独立的随机变量，其均值的分布以正态分布为极限，EX=sum(EX), DX=sum(DX)</li>
</ul>


<h3>大数定理</h3>

<ul>
<li>随着试验次数增多，事件发生的频率依机率收敛于事件的概率(频率的数学期望)</li>
</ul>


<h2>6.数理统计的基本概念</h2>

<h3>基本概念</h3>

<ul>
<li>研究对象全体的集合称为总体，总体中的每个元素称为个体</li>
<li>从总体中抽取部分的过程称为抽样</li>
<li>总体的分布称为理论分布，样本的分布称为经验分布</li>
<li>样本: X1&hellip;Xn相互独立且与总体X同分布，则(X1,&hellip;,Xn)是总体X的容量为n的简单随机样本</li>
<li>样本观测值: X1&hellip;Xn取一组常数时的值</li>
</ul>


<h3>简单随机抽样</h3>

<ul>
<li>随机性: 每次抽样，总体中每个个体都有同等机会被抽取</li>
<li>独立性: 每次抽取的结果既不影响其他各次抽取的结果，也不瘦其他各次抽取结果的影响</li>
<li>当样本数小于总体数1/10时，可以把不放回抽样近似作为放回抽样(简单随机抽样)处理</li>
</ul>


<h3>统计量</h3>

<ul>
<li>样本均值: ▔X = sum(Xi)/n</li>
<li>样本方差: S<sup>2</sup> = sum((Xi &ndash; ▔X)<sup>2</sup>)/(n-1)</li>
<li>样本标准差: S = [sum((Xi &ndash; ▔X)<sup>2</sup>)/(n-1)]^(&frac12;)</li>
<li>样本k阶原点矩: Ak = sum(Xi<sup>k</sup>)/n</li>
<li>样本k阶中心矩: Bk = sum((Xi &ndash; ▔X)<sup>k</sup>)/n</li>
</ul>


<h3>χ2分布</h3>

<ul>
<li>Xi~N(0,1), 统计量χ2=sum(Xi<sup>2</sup>), 则χ2服从自由度为n的χ2分布，记为χ2~χ2(n)</li>
<li>自由度n为平方和中随机变量的个数</li>
<li>Eχ2=n, Dχ2=2n</li>
</ul>


<h3>t分布</h3>

<ul>
<li>X~N(0,1), Y~χ2(n), 且X，Y相互独立，则T=X/(Y/n)<sup>&frac12;</sup>服从自由度为n的t(student)分布，记为T~t(n)</li>
<li>t分布是小样本(n&lt;45)下的分布，n->∞时，t分布接近于正态分布</li>
<li>Et=0</li>
</ul>


<h3>F分布</h3>

<ul>
<li>X~χ2(m), Y~χ2(n)，且X，Y相互独立，则F=(X/m)/(Y/n)服从自由度为(m,n)的F分布，记为F~F(m,n)</li>
<li>F(m,n) = 1/(F(n,m))</li>
</ul>


<h3>正态分布的样本均值与样本方差分布</h3>

<ul>
<li>总体的期望与方差为μ,σ<sup>2</sup>; 样本的期望与方差为▔X,S<sup>2</sup></li>
<li>▔X与S<sup>2</sup>相互独立</li>
<li>Xi~N(μ,σ<sup>2</sup>), 则▔X~N(μ,σ<sup>2</sup>/n)</li>
<li>(n-1)S<sup>2</sup>/σ<sup>2</sup> ~ χ2(n-1)</li>
<li>(▔X-μ)/S*n<sup>&frac12;</sup> ~ t(n-1)</li>
<li>(S1<sup>2</sup>/S2<sup>2</sup>)/(σ1<sup>2</sup>/σ2<sup>2</sup>) ~ F(n1-1,n2-1)</li>
</ul>


<h2>7.参数估计</h2>

<h3>估计量的评选原则</h3>

<ul>
<li>无偏性: 期望无偏</li>
<li>有效性: 无偏前提下选择方差最小，最小方差无偏估计量</li>
<li>一致性: 当样本数增大时，估计量的值能稳定为真实值的值</li>
</ul>


<h3>点估计</h3>

<ul>
<li>点估计: 用一个数值来a估计某个参数θ，主要包括点估计和极大似然估计</li>
<li>矩估计: 根据大数定理，随着样本增大，样本矩会逼近总体矩，故用样本矩估计总体矩</li>
<li>极大似然估计: 在一次抽样中，如果得到样本观测值(x1,&hellip;xn), 则选择(θ1,&hellip;θn)的θ估计，使得(x1,&hellip;xn)出现的概率最大</li>
</ul>


<h3>区间估计</h3>

<ul>
<li>区间估计: 求出一个区间(θ1,θ2), 使得参数θ以概率1-α被该区间覆盖，P(θ1&lt;θ&lt;θ2)=1-α，区间(θ1,θ2)称为θ的置信水平为1-α的置信区间，θ1/θ2分别为置信下限和置信上限，1-α称为置信水平</li>
</ul>


<h4>单个正态总体均值(σ<sup>2</sup>已知)</h4>

<ul>
<li>▔X~N(μ,σ<sup>2</sup>/n), (▔X-μ)*n<sup>&frac12;</sup>/σ ~ N(0,1)</li>
<li>置信区间为(▔X-σ/(n<sup>&frac12;</sup>)<em>u[α/2], ▔X+σ/(n<sup>&frac12;</sup>)</em>u[α/2])</li>
<li>置信区间长度l = 2σ/(n<sup>&frac12;</sup>)*u[α/2]，与σ成正比，与n<sup>&frac12;</sup>成反比</li>
</ul>


<h4>单个正态总体均值(σ<sup>2</sup>未知)</h4>

<ul>
<li>(▔X-μ)*n<sup>&frac12;</sup>/S ~ t(n-1)</li>
<li>置信区间为(▔X-t[α/2](n-1)<em>S/(N<sup>&frac12;</sup>),▔X+t[α/2](n-1)</em>S/(N<sup>&frac12;</sup>))</li>
</ul>


<h4>单个正态总体方差(μ未知)</h4>

<ul>
<li>(n-1)S<sup>2</sup>/σ<sup>2</sup> ~ χ2(n-1)</li>
<li>置信区间为((S<em>(n-1)<sup>&frac12;</sup>/(χ2[α/2](n-1))<sup>&frac12;</sup>),(S</em>(n-1)<sup>&frac12;</sup>/(χ2[1-α/2](n-1))<sup>&frac12;</sup>))</li>
</ul>


<h2>8.假设检验</h2>

<ul>
<li>原假设: H0, 如μ=μ0=0.5</li>
<li>备择假设: H1, 原假设的对立假设</li>
<li>检验统计量: 构造小概率事件用的统计量，如μ</li>
<li>接受域/拒绝域/临界点</li>
</ul>


<h3>两类错误</h3>

<ul>
<li>第一类错误: 弃真，P(拒绝H0|H0为真)=α</li>
<li>第二类错误: 存伪，P(接受H0|H0不为真)=β</li>
<li>显著性检验只控制第一类错误的α而不考虑第二类错误</li>
</ul>


<h3>假设检验步骤</h3>

<ul>
<li>根据实际问题提出原假设H0和备择假设H1</li>
<li>构造适当的检验统计量θ，在H0为真时其分布已知</li>
<li>对于给定置信水平α确定拒绝域W</li>
<li>根据统计量的观测值确定是接收H0还是拒绝H0</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[APUE笔记]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/10/31/APUE%E7%AC%94%E8%AE%B0/"/>
    <updated>2014-10-31T21:15:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/10/31/APUE笔记</id>
    <content type="html"><![CDATA[<h1>APUE笔记</h1>

<h2>1.UNIX System Overview</h2>

<h3>Nonfatal error(man 3 errno)</h3>

<ul>
<li>EAGAIN/EWOULDBLOCK</li>
<li>ENFILE/ENOBUFS/ENOLCK/ENOSPC/ENOSR/ENOMEM/EBUSY</li>
</ul>


<h3>键盘信号</h3>

<ul>
<li>Ctrl+Z SIGTSTP</li>
<li>Ctrl+C SIGINT</li>
<li>Ctrl+D EOF</li>
<li>Ctrl+/ SIGQUIT</li>
</ul>


<h2>2.UNIX Standardization and Implementations</h2>

<ul>
<li>ISO C/POSIX/XSI</li>
<li>FreeBSD/Linux/MacOS/Solaris</li>
<li>gcc -D_POSIX_C_SOURCE=200112 file.c</li>
</ul>


<h2>3.File I/O</h2>

<h3>open/close</h3>

<ul>
<li>O_RDONLY/O_WRONLY/O_RDWR</li>
<li>O_APPEND/O_TRUNC/O_CREAT/O_EXCL/O_NONBLOCK</li>
<li>O_SYNC(write data&amp;attr)/O_DSYNC(write data)/O_RSYNC(read)</li>
<li>sync(all)/fsync(single)/fdatasync</li>
</ul>


<h3>read/write</h3>

<h3>lseek</h3>

<ul>
<li>SEEK_CUR/SEEK_SET/SEEK_END</li>
<li>pread/pwrite: lseek+read/write</li>
</ul>


<h3>dup/dup2</h3>

<ul>
<li>dup(fd): fcntl(fd, O_DUPFD, 0)</li>
<li>dup2(fd1, fd2): close(fd2);fcntl(fd1, O_DUPFD, fd2)</li>
</ul>


<h3>fcntl</h3>

<ul>
<li>F_DUPFD</li>
<li>F_GETFD/F_SETFD(file descriptor, FD_CLOEXEC only)</li>
<li>F_GETFL/F_SETFL(file status, O_NONBLOCK and so on)</li>
<li>F_GETOWN/F_SETOWN</li>
<li>F_GETLK/F_SETLK/F_SETLKW</li>
<li>ioctl(driver, no need to known)</li>
</ul>


<h2>4.Files and Directories</h2>

<h3>stat(file path)/fstat(file decriptor id)/lstat(show symbolic link)</h3>

<ul>
<li>st_mode(file type&amp;permission)</li>
<li>st_ino/st_dev/st_rdev</li>
<li>st_nlink</li>
<li>st_uid/st_gid</li>
<li>st_size</li>
<li>st_atime[ls -u] last access , read()</li>
<li>st_mtime[ls] last modify, write()</li>
<li>st_ctime[ls -c] last inode status chagne, chown()</li>
<li>st_blksize</li>
<li>st_blocks(number of disk block allocate)</li>
</ul>


<h3>File Type</h3>

<ul>
<li>Regular file(S_ISREG)</li>
<li>Directory file(S_ISDIR)</li>
<li>Block special file(S_ISBLK)</li>
<li>Character special file(S_ISCHR)</li>
<li>FIFO(S_ISFIFO)[named pipe]</li>
<li>Socket(S_ISSOCK)</li>
<li>Symbolic link(S_ISLNK)</li>
</ul>


<h3>IPC</h3>

<ul>
<li>MQ message queue</li>
<li>SEM semaphore</li>
<li>SHM shared memory object</li>
</ul>


<h3>Process uid/gid</h3>

<ul>
<li>real userID/groudID(who excute the process)</li>
<li>effective userID/groupID(the permisson check)[by default is real userID/groupID, use set-user-id to be the file owner]</li>
<li>saved set-user-ID/groud-ID(save the last effective when effective change)</li>
<li>supplement group IDs</li>
</ul>


<h3>File Access Permissions</h3>

<ul>
<li>R:4, W :2, X:1</li>
<li>S_I(R/W/X)(USR/GRP/OTH)</li>
<li>open file need X for directory(if you known this file, R is no need)</li>
<li>list file need R for directory</li>
<li>create/ delete file need W&amp;X for directory, W for file is no need</li>
<li>access(path, mode): access permission test</li>
<li>umask(cmask): set the access permission for file this process create, turn off the bit in cmask</li>
<li>fchmod(fd, mode)</li>
</ul>


<h3>chown/fchown/lchown</h3>

<ul>
<li>chwon(path,owner,group)</li>
<li>chown -R user:group file/directory</li>
</ul>


<h3>file system</h3>

<ul>
<li>driver/parition(one file system per partition)/cylinde/(inodes+blocks)</li>
<li>a inode is a file, point to many data block</li>
<li>a inode can be link from many directory, when not process open the file and all directory unlink, delete the inode, but the data block still exist[hard link, just add st_nlink, create hard link for directory is not allowed]</li>
<li>symbolic link: add a new inode point to source file path, no add st_nlink</li>
<li>link(oldpath,newpath), symlink(actualpath,sympath), unlink(path), remove(path), rename(old,new)</li>
<li>mkdir/rmdir/chdir/fchdir/getcwd</li>
<li>opendir/readdir/rewinddir/closedir/telldir/seekdir</li>
<li>DIR structure like FILE, with the offset</li>
<li>st_dev: major is the disk num, minor is the filesystem num</li>
<li>st_rdev: valid for character device &amp; block device, the real device it is on</li>
</ul>


<h2>5.Standard I/O Library</h2>

<h3>Stream Buffer</h3>

<ul>
<li>Fully Buffered</li>
<li>Line Buffered</li>
<li>Unbuffered</li>
</ul>


<h3>Stream Read&amp;Write</h3>

<h4>Character-at-a-time I/O:</h4>

<ul>
<li>getc(fp)/fgetc(fp)/getchar()</li>
<li>getchar()=getc(STDIN)</li>
<li>getc is macro and fgetc is function, they are same</li>
<li>ungetc(c,fp)[put char back into stream]</li>
<li>putc(c, fp)/fputc(c, fp)/putchar&copy;</li>
</ul>


<h4>Line-at-a-time I/O:</h4>

<ul>
<li>fgets(buf,n,fp)</li>
<li>fputs(str,fp)</li>
</ul>


<h4>Direct I/O(Binary I/O):</h4>

<ul>
<li>fread(ptr, size, n, fp)</li>
<li>fwrite(ptr, size, n, fp)</li>
<li>ftell(fp)/fseek(fp, offset, whence)/rewind(fp)</li>
</ul>


<h3>Formatted I/O</h3>

<ul>
<li>printf(format, &hellip;)</li>
<li>fprintf(fp, format, ..)</li>
<li>sprintf(buf, format, ..)</li>
<li>snprintf(buf, n, format, &hellip;)</li>
<li>scanf(format, &hellip;)</li>
<li>fscanf(fp, format, &hellip;)</li>
<li>sscanf(buf, format, &hellip;)</li>
</ul>


<h3>Temporary Files</h3>

<ul>
<li>char *tmpname(ptr)</li>
<li>char *tempnam(directory, prefix)</li>
<li>File* tmpfile()</li>
<li>int mktemp(template)[return fd]</li>
<li>tmpname&amp;tempnam都有time window问题，应使用temfile&amp;mktemp</li>
</ul>


<h2>6.System Data Files and Information</h2>

<h3>Password File</h3>

<ul>
<li>passwd <em>getpwuid(uid)/passwd </em>getpwnam(name)</li>
<li>passwd *getpwent()[get by next, null return by end]</li>
<li>setpwent()[open/rewind]</li>
<li>endpwent()[close]</li>
</ul>


<h3>Shadow File(保存加密后的密码)</h3>

<ul>
<li>spwd *getspnam(name)</li>
<li>spwd *getspent()/setspent()/endspent()</li>
</ul>


<h3>Group File</h3>

<ul>
<li>group <em>getgrgid(gid)/group </em>getgrnam(name)</li>
<li>group *getgpent()/setgrent()/endgrent()</li>
<li>char **group->gr_mem指向属于本group的user_name</li>
<li>Supplementary Group IDs make a user can belong up to 16 addtional groups</li>
</ul>


<h3>Datetime</h3>

<ul>
<li>time_t time(time_t *) seconds from Epoch</li>
<li>gettimeofday(timeval *, NULL) seconds &amp; microseconds from Epoch</li>
<li>tm <em>gmtime(time_t </em>) time_t to tm UTC(calendar form)</li>
<li>tm <em>localtime(time_t </em>) time_t to tm local timezone</li>
<li>time_t mktime(tm *) tm to time_t</li>
<li>char <em>asctime(tm </em>) tm to string</li>
<li>char <em>ctime(time_t </em>) time_t to string</li>
<li>strftime(buf, maxsize, format, tm*) tm to format string</li>
</ul>


<h2>7.Process Environment</h2>

<h3>Process Termination</h3>

<ul>
<li>terminate method</li>
<li>return from main()</li>
<li>return from last thread</li>
<li>call exit()</li>
<li>call <em>exit()/</em>Exit()</li>
<li>call pthread_exit()</li>
<li>call abort</li>
<li>receipt a signal</li>
<li>last thread response for a cancel request</li>
<li>exit(0) is same as return 0 by main</li>
<li>exit will call exit handle register by atexit() and clean up standard I/O, <em>exit &amp; </em>Exit will not</li>
</ul>


<h3>Memory Layout(From low address to high)</h3>

<ul>
<li>Text Segment(Code Segment)</li>
<li>Initialized Data Segment(Data Segment)</li>
<li>Uninitialized Data Segment(Block Started by Symbol, BSS)</li>
<li>Heap</li>
<li>Stack</li>
</ul>


<h3>Memory Allocate</h3>

<ul>
<li>malloc(size)</li>
<li>cmalloc(nobj, size) malloc+memset(0)</li>
<li>remalloc(ptr,size)</li>
<li>free(ptr)</li>
</ul>


<h3>Environment Variables</h3>

<ul>
<li>int main(int argc, char <em>argv[], char </em>envp[])</li>
<li>getenv(name)/putenv(name=value)/setenv(name,value)/unsetenv(name)</li>
</ul>


<h3>Others</h3>

<ul>
<li>goto only available in same function, use setjmp/longjmp to cross function</li>
<li>getrlimit/setrlimit, return resource limit for the process(rlimit)</li>
<li>struct rlimit{
  rlim_t rlim_cur; //soft limit
  rlim_t rlim_max; //hard limit
}</li>
<li>soft limit should lower or equal to hard limit, only root user can change hard limit</li>
</ul>


<h2>8.Process Control</h2>

<h3>Process Identifier</h3>

<ul>
<li>getpid()/getppid()</li>
<li>getuid()/geteuid()</li>
<li>getgid()/getegid()</li>
</ul>


<h3>Process Creation</h3>

<ul>
<li>fork(), call once, return twice</li>
<li>parent &amp; child process by fork share Text Segment, other segment are independent, copy on write</li>
<li>parent &amp; child process share file discriptors open</li>
<li>signal &amp; File Lock are not inherited from parent to child</li>
<li>vfork(), the parent and child share all resource, the parent wait unit child exit, it always use to call exec()</li>
</ul>


<h3>Process Termination</h3>

<ul>
<li>wait(&amp;return_status), wait for any child terminated, return by the first child</li>
<li>waitpid(pid,&amp;return_status,option), wait for the specified child terminated</li>
<li>init process become parent for whos parent terminated</li>
<li>child process will be zombie when it terminate but parent not wait for it</li>
<li>child terminated then the process will receive SIGCHLD, default behavior is ignore it</li>
</ul>


<h3>Exec Function</h3>

<ul>
<li>exec[l/v]<a href="filepath,%20argv[],%20envp[]"> /e/p</a>, only execve is system call</li>
<li>exec function replace the text segment/data segment/bss/heap/stack by the programe specified by filepath</li>
<li>exec keep the file discriptor open, but fcntl FD_CLOEXEC can close them</li>
<li>#! /bin/sh</li>
<li>system = fork + exec + waitpid</li>
</ul>


<h3>Change user IDs and group IDs</h3>

<ul>
<li>setuid/setgid</li>
<li>uid or gid only can be set by root, or set to real-user/saved-user/file-owner-user</li>
</ul>


<h3>Accounting</h3>

<ul>
<li>real(实际运行时间)</li>
<li>user(用户态CPU时间)</li>
<li>sys(内核态CPU时间)</li>
</ul>


<h2>9.Process Relationships</h2>

<ul>
<li>ssh beyond tcp protocol</li>
<li>Terminal Login &amp; NetworkLogin(Pseudo Terminal)</li>
<li>a login is a session, a session contain some foreground/backgroud process groups, process groups include one or more process</li>
<li>$ proc1 | proc2 &amp; : proc1 and proc2 consist of a backgound group</li>
<li>$ proc3 | proc4 : proc3 and proc4 consist of a foregound group</li>
<li>Ctrl + C/Delete: send SIGINT to all foreground process</li>
<li>Ctrl + /: send SIGQUIT to all foreground process</li>
<li>Ctrl + Z: send SIGTSTP to all foreground process, 使用bg命令查询有哪些挂起的，使用fg命令重新带回前台</li>
<li>background process input/oupt to terminal wil send SIGTTIN/SIGTTOUT and then stop until use fg command to bring them to foreground</li>
</ul>


<h2>10.Signals</h2>

<h3>Generate</h3>

<ul>
<li>User inout from terminal</li>
<li>Hardware exception(invalid memory)</li>
<li>kill(1, command)/(2, function)</li>
<li>Software condition(SIGPIPE)</li>
</ul>


<h3>Behavior</h3>

<ul>
<li>Ignore(SIGKILL/SIGSTOP can&rsquo;t ignore)[SIG_IGN]</li>
<li>catch and deal[void (*func)(int)]</li>
<li>default action[SIG_DFL]</li>
</ul>


<h3>Default Action</h3>

<ul>
<li>terminate(SIGHUP)</li>
<li>terminate+core(SIGABRT/SIGFPE/SIGSEGV/SIGSYS/SIGXCPU/SIGXFSZ)</li>
<li>continue process</li>
<li>stop process</li>
<li>ignore</li>
</ul>


<h3>Slow System Calls</h3>

<ul>
<li>read/write</li>
<li>open</li>
<li>pause</li>
<li>ioctl</li>
<li>some IPC funcitons</li>
<li>the slow system calls will be restart after the signal</li>
</ul>


<h3>Reentrant Functions</h3>

<ul>
<li>文件操作/Socket操作/进程操作系列函数是Reentrant的</li>
<li>malloc/free/标准IO(printf)/errno/使用全局数据结构的函数是非Reentrant的</li>
</ul>


<h3>可重入与线程安全</h3>

<ul>
<li>可重入：有一类重要的线程安全函数，叫做可重入函数，其特点在于它们具有一种属性：当它们被多个线程调用时，不会引用任何共享的数据。与多线程无关，一个函数被多次调用[信号中断]但结果具有可重现性[没有全局数据，不调用非可重入函数]，不会受其他函数影响，输入输出一对一，Linux以_r结尾的函数是可重入的</li>
<li>线程安全：一个函数同时被多个线程调用而得到正确结果[使用互斥锁保证，访问全局数据]，同样的输入可能有不同的输出</li>
<li>可重入是线程安全的子集，</li>
</ul>


<h2>signal/kill</h2>

<ul>
<li>Linux的signal函数内部调用sigaction，不需要每次调用后重置信号行为且是可靠的</li>
<li>kill(pid, sig) pid>0进程号为pid的进程;pid=0同一进程组进程;pid&lt;0进程组为-pid的进程;pid=-1发给除了自身外所有id>1的进程</li>
<li>非root权限的进程只能发信号给同一个session或者同一个用户的进程</li>
<li>多线程程序共享同样的信号处理函数，一个进程中有多个线程则会随机使用一个线程进行处理</li>
</ul>


<h2>alarm&amp;pause</h2>

<ul>
<li>多个信号同时发生会发生类似于栈嵌套执行，即一个信号处理一半中断了处理新收到的信号，处理返回处理栈上一个信号，待所有信号处理完再运行进程的代码</li>
<li>alarm(second)，second秒后产生一个SIGALRM，一个进程只能有一个alarm，一个新的alarm生效前一个则会失效，sleep内部也是使用alarm实现，所以不要混用sleep和alarm</li>
<li>pause函数使进程进入睡眠状态直到捕获任何信号</li>
</ul>


<h2>block sign</h2>

<ul>
<li>sigemptyset/sigfillset/sigaddset/sigdelset/sigismember</li>
<li>sigprocmask Block/Unblock哪些信号</li>
<li>sigpending 返回被Block的信号</li>
</ul>


<h2>11.Threads</h2>

<h3>Thread Identification</h3>

<ul>
<li>pthread_equal/pthread_self</li>
<li>每一个线程拥有自己的stack/register value/signal mask/errno</li>
</ul>


<h3>Thread Creation&amp;Termination</h3>

<ul>
<li>pthread_create</li>
<li>pthread_exit/pthread_cancel</li>
<li>pthread_cleanup_push/pthread_cleanup_pop</li>
<li>pthread_join/pthread_detach</li>
</ul>


<h3>Thread Synchronization</h3>

<h4>Mutex</h4>

<ul>
<li>pthread_mutex_init/pthread_mutex_destroy/PTHREAD_MUTEX_DESTORY</li>
<li>pthread_mutex_lock/pthread_mutex_unlock/pthread_mutex_try_lock</li>
</ul>


<h4>Reader-Writer Locks</h4>

<ul>
<li>pthread_rwlock_init/pthread_rwlock_destory</li>
<li>pthread_rwlock_rdlock/pthread_rwlock_wrlock/pthread_rwlock_unlock</li>
<li>pthread_rwlock_tryrdlock/pthread_rwlock_trywrlock</li>
</ul>


<h4>Condition Variables</h4>

<ul>
<li>pthread_cond_init/pthread_cond_destory</li>
<li>pthread_cond_wait/pthread_cond_timewait</li>
<li>pthread_cond_signal/pthread_cond_broadcast</li>
</ul>


<h2>hange the attribute appear in Chapter 11</h2>

<ul>
<li>pthread_once:某个函数只执行一次，用于单例模式</li>
<li>__thread声明的变量每个线程拥有独立的值</li>
</ul>


<h2>13.Daemon Process</h2>

<h3>Coding Rules</h3>

<ul>
<li>umask(0) 清除不必要的权限位</li>
<li>fork+parent exit</li>
<li>setsid 创建新会话，脱离中断</li>
<li>chdir(/) 当前目录可能重启后不存在(如果是挂载的)</li>
<li>close unneeded file discriptor</li>
<li>open 0/&frac12; to /dev/null 防止读写终端</li>
</ul>


<h3>Error Logging</h3>

<ul>
<li>syslog(level, fmt, &hellip;)</li>
</ul>


<h3>TIP</h3>

<ul>
<li>调用系统函数daemon(int nochdir, int noclose)直接完成该功能</li>
<li>用于服务器端程序</li>
<li>使用基于File的RecordLock来生成单例Daemon</li>
</ul>


<h3>Daemon Conventions</h3>

<ul>
<li>lock file in /var/run/name.pid</li>
<li>config file in /etc/name.conf</li>
<li>auto-start script in /etc/rc<em> or /etc/init.d/</em> or /etc/inittab</li>
<li>use SIGHUP to notify the daemon reload config file</li>
</ul>


<h2>14.Advanced I/O</h2>

<h3>Nonblock I/O</h3>

<ul>
<li>set with open(fd, O_NONBLOCK)</li>
<li>set with fcntl()</li>
</ul>


<h3>Record Lock</h3>

<ul>
<li>支持对一个文件的区域进行锁</li>
</ul>


<h3>STREAMS</h3>

<h3>I/O Multiplexing</h3>

<ul>
<li>select/poll</li>
<li>readv/writev/readn/writen</li>
</ul>


<h3>Memory-Mapped I/O</h3>

<ul>
<li>mmap</li>
</ul>


<h2>15.Interprocess Communication</h2>

<h3>Default IPC</h3>

<h4>Pipes</h4>

<ul>
<li>pipe(field[2])</li>
<li>打开后使用/read/write操作，最后一个使用进程退出会自动关闭</li>
<li>half-duplex</li>
<li>work between process have a common ancestor</li>
<li>is a file discriptor</li>
<li>popen/pclose</li>
</ul>


<h4>FIFOS(named pipes)</h4>

<ul>
<li>mkfifo</li>
<li>打开后使用open/read/write操作</li>
<li>cross process without a common ancester</li>
<li><ul>
<li>is a file discriptor</li>
</ul>
</li>
</ul>


<h4>SIGNAL</h4>

<h3>XSI IPC</h3>

<h4>Message Queue</h4>

<h4>Semaphore</h4>

<h4>Shared Memory</h4>

<h4>Advantage&amp;Disadvantage</h4>

<ul>
<li>XSI IPC是全局的，需要手动关闭</li>
<li>使用full-duplex pipe替换MQ</li>
<li>使用record-lock替换semaphore</li>
<li>使用mmap替换shared memory</li>
</ul>


<h2>16.Network IPC: Sockets</h2>

<h3>TCP Status</h3>

<h4>起始</h4>

<ul>
<li>CLOSED</li>
</ul>


<h4>连接</h4>

<ul>
<li>被动打开: LISTEN/SYN_RCVD</li>
<li>主动打开: SYN_SENT</li>
</ul>


<h4>传输中</h4>

<ul>
<li>ESTABLISHED</li>
</ul>


<h4>断开</h4>

<ul>
<li>主动断开:FIN_WAIT_1/FIN_WAIT_2/CLOSING(同时断开)/TIME_WAIT</li>
<li>被动断开:CLOSE_WAIT/LAST_ACK</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++类型转换笔记]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/07/22/C%2B%2B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%AC%94%E8%AE%B0/"/>
    <updated>2014-07-22T21:19:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/07/22/C++类型转换笔记</id>
    <content type="html"><![CDATA[<h1>C语言默认</h1>

<ul>
<li>int(a)</li>
<li>(int)a</li>
</ul>


<h1>std::static_cast</h1>

<ul>
<li>效果同C语言默认</li>
<li>派生类向上转换为基类（安全）</li>
<li>基类向下转换为派生类（不安全，必须程序员保证）</li>
</ul>


<h1>std::dynamic_cast</h1>

<ul>
<li>基类向下转换为派生类（安全）</li>
<li>引用的话抛出std::bad_cast，指针返回空指针</li>
<li>运行时检查，依赖于虚函数表，基类必须有虚函数，效率比static_cast低</li>
</ul>


<h1>std::reinterpret_cast</h1>

<ul>
<li>把任意一个指针或算术类型转为任意其他指针或算术类型</li>
<li>一般只用于把指针转为int或int转为指针</li>
</ul>


<h1>std::const_cast</h1>

<ul>
<li>用来去掉变量的const/volatile属性</li>
</ul>


<h1>boost::polymorphic_cast</h1>

<ul>
<li>与dynamic_cast类型，但指针和引用转换失败都抛出std::bad_cast</li>
</ul>


<h1>boost::polymorphic_downcast</h1>

<ul>
<li>debug使用dynamic_cast，release使用static_cast</li>
<li>貌似能提高效率，但一般不要使用</li>
</ul>


<h1>boost::numeric_cast</h1>

<ul>
<li>用来防止较大的类型转成较小类型的数值回绕问题和有符号数转为无符号数的符号错误，失败抛出boost::bad_numeric_cast</li>
<li>doulbe转成float如果只是损失小数点精度的话不会抛出异常</li>
<li>sizeof(T)/std::numeric_limits<T>::max()获得类型的大小</li>
</ul>


<h1>boost::lexical_cast</h1>

<ul>
<li>把数值类型转为字符串类型 string a = boost::lexical_cast<string>(123)</li>
<li>把字符串类型转为数值类型 int a = boost::lexical_cast<int>(&ldquo;12&rdquo;)</li>
<li>失败抛出bad_lexical_cast</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mutex&Lock笔记]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/07/22/Mutex%26Lock%E7%AC%94%E8%AE%B0/"/>
    <updated>2014-07-22T21:15:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/07/22/Mutex&Lock笔记</id>
    <content type="html"><![CDATA[<h1>Mutex</h1>

<h2>Eclusive Ownership</h2>

<ul>
<li>mutex，一个简单的mutex只能被锁住一次，假如同一线程试图两次锁定mutex，将会产生死锁。</li>
<li>recursive mutex，一个线程可以多次锁定一个mutex，但必须以同样的次数对mutex进行解锁，否则其他线程将无法锁定该mutex。</li>
<li>shared mutex，多个线程读，单个线程写，lock/shared_lock，使用一个unique_lock和一个shared_lock对一个shared_mutex操作可以实现读写锁</li>
</ul>


<h2>获取锁行为</h2>

<ul>
<li>等待并试图对mutex加锁，直到没有其他线程锁定mutex；</li>
<li>试图对mutex加锁，并立即返回，假如其他线程锁定了mutex；</li>
<li>等待并试图对mutex加锁，直到没有其他线程锁定mutex或者直到规定的时间已过。</li>
</ul>


<h2>分类</h2>

<ul>
<li>mutex(try_mutex)</li>
<li>timed_mutex</li>
<li>recursive_mutex</li>
<li>recursive_timed_mutex</li>
<li>shared_mutex</li>
</ul>


<h1>Lock</h1>

<h2>分类</h2>

<ul>
<li>lock_guard 利用RAII的最简单实现</li>
<li>unique_lock 在lock_guard的基础上提供了try_lock()/timed_lock</li>
<li>shared_lock 读写锁中的读锁</li>
<li>upgrade_lock  未明</li>
</ul>


<h1>Reference</h1>

<ul>
<li><a href="http://www.boost.org/doc/libs/1_41_0/doc/html/thread/synchronization.html">Boost Synchronization</a></li>
<li><a href="http://zh.highscore.de/cpp/boost/multithreading.html">Boost多线程</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ Tip]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/07/22/cpp-tips/"/>
    <updated>2014-07-22T21:12:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/07/22/cpp-tips</id>
    <content type="html"><![CDATA[<h1>C++</h1>

<ul>
<li>虚函数是为了用基类指针能调用子类函数，虚函数必须有实现</li>
<li>纯虚函数是为了使类不能被实例化定义接口。纯虚函数只有声明</li>
<li>基类向下转型成派生类</li>
<li>定义构造函数、复制构造函数、或赋值操作符三个中的任意一个,你也需要定义另外两个</li>
<li>使用class a:private boost::non copyable</li>
<li>泛型是水平的，把各种不同的互相没有什么关系的类型应用于同一种算法；继承是垂直的，从抽象到具体，子类和父类是有关系的。</li>
</ul>


<h1>Linux</h1>

<ul>
<li>一个线程结束时要通过pthread_join或者pthread_detach(pthread_self())来释放8K左右的堆栈和线程描述符</li>
<li>interrupt只有在代码执行到wait/join/sleep这三种检查点的时候才会中断</li>
</ul>


<h1>Others</h1>

<ul>
<li>聚合：离散聚合/累积聚合/滑动聚合</li>
<li>旋转：开放架构(id/attr/val)与Cube</li>
<li>UnitTest:Setup/Exercice/Verify/Teardown</li>
<li>gtest事件：Enviroment(SetUp/TearDown)/TestSuite(SetUp/TearDownTestCase)/TestCase(SetUp/TearDown)</li>
</ul>


<h2>Redis数据类型</h2>

<ul>
<li>String: set/get/desc/incr/mget</li>
<li>List: lpush/rpush/lpop/rpop/lrange</li>
<li>Hash: hget/hset/hgetall/hmset/hmget</li>
<li>Set: sadd/spop/smembers/sunion</li>
<li>Sorted Set: zadd/zrem/zrange</li>
<li>Sorted Set由HashSet(正排，key:score)+SkipList构成(倒排, score:key，类似平衡树，查找复杂度O(logn))</li>
</ul>


<h2>CouchBase数据类型</h2>

<ul>
<li>redis提供各种数据结构但CouchBase都是JSON</li>
<li>bucket 相当于数据库的db+table</li>
<li>set/add/replace</li>
<li>cas(key, oldval, newval) 替换为新值的时候值必须为旧值，保证数据一致性</li>
<li>get/delete/touch</li>
<li>append/prepend/incr/decr</li>
<li>lock(key, ttl)/unlock</li>
<li>with pipeline可以实现get_multi/set_multi等的批处理效果</li>
<li>通过MapReduce实现条件查询[View必须预先定义好，一个DesignDocument包括多个View], map函数中通过emit返回符合条件的数据进行reduce</li>
<li>开发模式增量数据会自动进行MapRedure加到View索引中，开发模式则不会</li>
</ul>


<h2>CAP</h2>

<ul>
<li>Consistency</li>
<li>Availability[快速获得数据]</li>
<li>Tolerance of network Partition[分布式]</li>
<li>一个分布式系统只能满足其中两个，不可能全部满足</li>
<li>CA:传统数据库</li>
<li>AP:K-V数据库</li>
</ul>


<h2>BASE</h2>

<ul>
<li>Base Availble</li>
<li>Soft-state(无连接)</li>
<li>Eventual Consistency</li>
</ul>


<h2>死锁形成条件(一个不符合则不会死锁)</h2>

<ul>
<li>资源互斥性[A占有B就不能占有]</li>
<li>资源不可剥夺</li>
<li>请求且保持[等待一个资源的时候不释放当前占有的资源]</li>
<li>循环等待</li>
</ul>


<h2>TCP/IP</h2>

<p>ESTABLISHED 表示正在通信，TIME_WAIT 表示主动关闭，CLOSE_WAIT 表示被动关闭。
ps -fu wuyixiang 查找我的进程
cat /proc/[pid]/status 查看pid的进程占用的内存大小(当前，峰值)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IO笔记]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/07/12/IO%E7%AC%94%E8%AE%B0/"/>
    <updated>2014-07-12T20:15:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/07/12/IO笔记</id>
    <content type="html"><![CDATA[<h2>Socket基本操作</h2>

<h3>TCP</h3>

<ul>
<li>Server:bind/listen/accept/read(write)/close</li>
<li>Client:bind/connect/read/write/close</li>
</ul>


<h3>UDP</h3>

<ul>
<li>Server:bind/sendto/recvfrom/close</li>
<li>Client:sendto/recvfrom/close</li>
</ul>


<h2>同步/异步/阻塞/非阻塞</h2>

<ul>
<li>同步 bool do();</li>
<li>异步 void do(); 事件:void onResult(bool result);[通知方式]</li>
<li>阻塞 直到数据就绪为止</li>
<li>非阻塞 不管数据有没有就绪直接返回</li>
<li>同步下区分阻塞和非阻塞，异步不区分，三种系统I/O:同步阻塞/同步非阻塞/异步非阻塞</li>
</ul>


<h2>Reactor/Proactor</h2>

<h3>组成元素</h3>

<ul>
<li>事件源(fd/socket)</li>
<li>事件多路分发机制(select/poll)</li>
<li>Reactor(事件注册/循环/回调/移除)</li>
<li>Event Handler(事件处理方法)</li>
</ul>


<h3>区别</h3>

<ul>
<li>reactor通知好的时候数据还没有写入缓冲区，需要自己去读写(同步)[libevent]</li>
<li>proactor通知好的时候操作系统已经把数据写入缓冲区，不需要自己去读写(异步)[asio]</li>
</ul>


<h3>Reference</h3>

<ul>
<li><a href="http://blog.csdn.net/sparkliang/article/details/4957744">libevent源码深度剖析</a></li>
<li><a href="http://www.boost.org/doc/libs/1_55_0/doc/html/boost_asio.html">boost.asio</a></li>
</ul>


<h1>select/poll/epoll/kqueue</h1>

<p>本质都是多路复用机制，select/poll都是轮询内核，epoll/kqueue采用中断信号回调</p>

<ul>
<li><p>select的缺点如下：</p>

<blockquote><ul>
<li>最大并发数（默认1024/2048）</li>
<li>效率（线性扫描，O(N)，活跃不活跃都要测试，大量不活跃的时候性能很差）</li>
<li>内核/用户空间（采用内存拷贝）</li>
</ul>
</blockquote></li>
<li><p>poll修正了最大并发数问题</p></li>
<li>epoll修正了最大并发数，效率（只跟活跃有关，O(k)），内核/用户空间（共享内存）</li>
<li>kqueue类似于epoll，不同平台的实现</li>
</ul>


<h2>边缘/水平触发</h2>

<ul>
<li>边缘触发(level)

<blockquote><p>每当状态变化时发生一个io事件；
有事了，告诉你一次，你不处理？拉倒！</p></blockquote></li>
<li>水平触发(edge)

<blockquote><p>只要满足条件就发生一个io事件；
有事了，你不处理？不断骚扰你直到你处理</p></blockquote></li>
</ul>


<h1>TCP/UDP</h1>

<ul>
<li>TCP要点有四，一曰有连接，二曰可靠传输，三曰数据按照到达，四曰端到端流量控制。</li>
<li>IP层提供的核心基本功能有两点，第一点是地址管理，第二点就是路由选路。</li>
<li>TCP3次握手,4次挥手用于保证双方都终止数据传输</li>
<li>UDP可以一个Client Socket连多个Server，TCP只能一对一</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式笔记]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/07/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    <updated>2014-07-10T20:15:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/07/10/设计模式笔记</id>
    <content type="html"><![CDATA[<h2>分类</h2>

<h3>创建（5+1）</h3>

<ul>
<li>工厂(Factory)</li>
<li>简单工厂(Simple Factory)</li>
<li>抽象工厂(Abstract Factory)</li>
<li>原型(Protoype)</li>
<li>单例(Singleton)</li>
<li>建造者(Builder)</li>
</ul>


<h3>结构（7）</h3>

<ul>
<li>组合(Composite)</li>
<li>代理(Proxy)</li>
<li>装饰(Decorator)</li>
<li>桥接(Bridge)</li>
<li>享元(Flyweight)</li>
<li>适配器(Adaptor)</li>
<li>外观(Facade)</li>
</ul>


<h3>行为（11）</h3>

<ul>
<li>模板方法(Template Method)</li>
<li>状态(State)</li>
<li>策略(Strategy)</li>
<li>观察者(Observer)</li>
<li>迭代器(Iterator)</li>
<li>责任链(Chain of Responsibility)</li>
<li>命令(Command)</li>
<li>访问者(Visitor)</li>
<li>备忘录(Memento)</li>
<li>中介者(Mediator)</li>
<li>解释器(Intepretor)</li>
</ul>


<h2>TIP</h2>

<ul>
<li>代理模式用于控制访问，用户不知道被代理的对象；装饰器模式用于新增行为，用户知道被被装饰的对象并在构造函数中传递给装饰器。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式笔记]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/07/10/%E6%A8%A1%E6%9D%BF.md.tmp/"/>
    <updated>2014-07-10T20:15:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/07/10/模板.md.tmp</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据库笔记]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/07/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    <updated>2014-07-06T20:15:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/07/06/数据库范式笔记</id>
    <content type="html"><![CDATA[<h2>范式比较</h2>

<h3>1NF</h3>

<p>数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。</p>

<h3>2NF</h3>

<p>非主属性完全依赖于主键[消除非主属性对主码的<strong>部分函数依赖</strong>]</p>

<h3>3NF</h3>

<p>非主属性不依赖于其它非主属性[消除了非主属性<strong>传递依赖</strong>]</p>

<h3>BCNF</h3>

<p>所有属性不依赖于任何候选关键字（一个表中只能有一个候选关键字）[消除了主属性<strong>传递依赖</strong>]</p>

<h3>4NF</h3>

<h3>5NF</h3>

<h2>概念定义</h2>

<h3>多值依赖</h3>

<p>设R(U)是一个属性集合U上的一个关系模式，X, Y, 和Z是U的子集，并且Z=U-X-Y，多值依赖X->&ndash;>Y成立当且仅当对R的任一个关系r，r在(X,Z)上的每个值对应一组Y的值，这组值仅仅决定于X值而与Z值无关。
若X->&ndash;>Y，而Z=空集，则称X->&ndash;>Y为平凡的多值依赖。
否则，称X->&ndash;>Y为非平凡的多值依赖。</p>

<h3>函数依赖</h3>

<p>可以看出，如果把上面的一组改为一个，那么多值依赖就变成了函数依赖。当然一个值组成的组也是组，所以说，函数依赖是多值依赖的特殊情况。</p>

<h2>TIP</h2>

<ul>
<li>1NF~BCNF消除函数依赖，4NF~5NF消除多值依赖</li>
<li>2NF-3NF都消除了数据冗余、更新异常、插入异常和删除异常</li>
</ul>


<h2>参考</h2>

<p><a href="http://www.bkent.net/Doc/simple5.htm">A Simple Guide to Five Normal Forms in Relational Database Theory</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[智能指针笔记]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/07/04/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AC%94%E8%AE%B0/"/>
    <updated>2014-07-04T19:25:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/07/04/智能指针笔记</id>
    <content type="html"><![CDATA[<h2>std::auto_ptr</h2>

<h3>定义</h3>

<p>通过在析构函数里delete实现自动内存释放，实现大概50行代码以内</p>

<h3>TIP</h3>

<ul>
<li>一个原始指针只能有一个auto_ptr拥有其所有权</li>
<li>不支持值语义，赋值、拷贝操作之间转移所有权，原来的autor_ptr拥有一个空指针</li>
<li>不支持值语义所以不能放入STL容器中</li>
<li>使用delete所以不能传入数组指针</li>
</ul>


<h2>boost::scoped_ptr</h2>

<h3>TIP</h3>

<ul>
<li>实现原理与auto_ptr类似，不过不支持赋值、拷贝操作，其余类似</li>
<li>超出智能指针作用域利用析构自动delete故称为scoped，RAII</li>
</ul>


<h2>boost::scoped_array</h2>

<h3>TIP</h3>

<ul>
<li>实现与scoped_ptr一样，只不过是用delete[]来释放内存</li>
<li>一般用vector而不要用这个</li>
</ul>


<h2>boost::shared_ptr</h2>

<h3>定义</h3>

<p>引用计数指针可以分为intrusive和non-intrusive两种，shared_ptr是一种non-instrusive的引用计数智能指针。</p>

<h3>TIP</h3>

<ul>
<li>一个原始指针只能有可以有多个shared_ptr拥有其所有权</li>
<li>shared_ptr可以放入容器之中</li>
<li>类型转换必须用static_pointer_cast</li>
<li>删除器必须是一个实现了operator()的函数对象或者函数指针</li>
<li>删除器函数对象示例boost::shared_ptr<FILE> my_shared_file(f,FileCloser());</li>
<li>删除器函数指针示例boost::shared_ptr<FILE> my_shared_file(f,&amp;fclose);</li>
<li>使用enable_shared_from_this:因为shared_ptr(T<em>)会认为只有他拥有T</em>，故新建立一个引用计数，为0时进行一次delete；而share_ptr(weak_ptr&lt;T<em>>)沿用原有的weak_ptr计数+1；shared_from_this实际是share_ptr(weak_ptr&lt;T</em>>);故当有函数的参数是shared_ptr<T>的时候T应当继承enable_shared_from_this</li>
</ul>


<h2>boost::shared_array</h2>

<h3>TIP</h3>

<ul>
<li>实现与shared_ptr一样，只不过是用delete[]来释放内存</li>
<li>一般用一个指向vector的shared_ptr指针而不要用这个</li>
</ul>


<h2>boost::intrusive_ptr</h2>

<h3>定义</h3>

<p>intrusive的引用计数智能指针，需要用户自己维护一个引用计数，并重载intrusive_ptr_add_ref和instrusive_ptr_release函数</p>

<h3>TIP</h3>

<ul>
<li>直接可以使用this而不需要像share_ptr要用enable_shared_from_this</li>
<li>一般还是用shared_ptr</li>
<li>据说智能指针的大小必须与裸指针的大小相等时也要用instrusive_ptr</li>
</ul>


<h2>boost::weak_ptr</h2>

<h3>定义</h3>

<p>weak_ptr不增加引用计数</p>

<h3>TIP</h3>

<ul>
<li>可以观察资源并通过expired防止悬空指针</li>
<li>用于防止循环引用</li>
<li>生成shared_ptr:(1)通过构造函数构造(为空返回bad_weak_ptr);(2)通过lock方法(为空返回空shared_ptr)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[子串&子序列系列问题的动态规划转移方程]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/05/18/%E5%AD%90%E4%B8%B2%26%E5%AD%90%E5%BA%8F%E5%88%97%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B/"/>
    <updated>2014-05-18T21:34:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/05/18/子串&子序列系列问题的动态规划转移方程</id>
    <content type="html"><![CDATA[<h1>子串&amp;子序列系列问题的动态规划转移方程</h1>

<h2>问题分类</h2>

<h3>子串/子序列</h3>

<ul>
<li>子串: 必须是连续的</li>
<li>子序列: 可以是离散的</li>
<li>子串计算过程中中断会归零，但子序列是从头累加</li>
</ul>


<h3>最大和/最大递增/最长相同字符串</h3>

<ul>
<li>最大和</li>
<li>最大递增</li>
<li>最长公共字符串</li>
</ul>


<h2>最大子序列和 O(n)</h2>

<p>无意义，取所有不为负的即可</p>

<h2>最大子串和</h2>

<p>f(i) = max(f(i-1), 0), f(i)=sum(a[j]),j&lt;=i
maxV = f(n)</p>

<h2>最大递增子串</h2>

<p>f(i) = a[i]>a[i-1]?f(i-1) + 1:1, f(i)是以a[i]结尾的递增子串
maxV = max(f(i))</p>

<h2>最大递增子序列</h2>

<p>f(i) = max(f(j)) + 1, f(j)是以a[j]结尾的递增子序列，且a[j]&lt;a[i], j&lt;i
maxV = max(f(i))</p>

<h2>最长公共子串</h2>

<p>f(i,j) = a[i]==b[j]?f(i-1, j-1) + 1:0, f(i,j)是以a[i]结尾的a和以b[j]结尾的b的最大公共子串
maxV = max(f(i,j))</p>

<h2>最长公共子序列</h2>

<p>f(i,j) = max(f(i-1,j),f(i,j-1),f(i-1,j-1)+C), f(i,j)是以a[i]结尾的a和以b[j]结尾的b的最大公共子序列，C = a[i]==b[j]?1:0
maxV = f(m,n)</p>

<h2>字符串编辑距离</h2>

<p>f(i,i) = min(f(i-1,j)+1,f(i,j-1)+1,f(i-1,j-1)+C) f(i,j)是以a[i]结尾的a和以b[j]结尾的b的字符串编辑距离，C = a[i]==b[j]?1:0</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[有用的Shell命令和小技巧]]></title>
    <link href="http://CodePeasant.github.io/blog/2013/12/04/script-tips/"/>
    <updated>2013-12-04T20:38:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2013/12/04/script-tips</id>
    <content type="html"><![CDATA[<ul>
<li>在某个目录下查找含有某段文字的文件</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>grep QLStagePhoto -rl branches/
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>统计一个命令的运行时间</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">time </span>ls
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Ctrl+A 跳到当前行最前</li>
<li>Ctrl+U 清空当前行</li>
<li>Ctrl+I 清空整屏</li>
<li><p>一般输入某个命令加-h选项可以以利于人类阅读的方式显示，如ll -h/df -h</p></li>
<li><p>统计字符数/词数/行数</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>ls|wc -c/w/l
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>重复上个输入的命令</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>sudo !!
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>以当前目录为根目录启动HTTPServer，端口为8000</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>python -m SimpleHTTPServer
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>统计当前用户最常用的10个命令</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">history</span> | awk <span class="s1">&#39;{CMD[$2]++;count++;} END { for (a in CMD )print CMD[a] &quot; &quot; CMD[a]/count*100 &quot;% &quot; a }&#39;</span> | grep -v <span class="s2">&quot;./&quot;</span> | column -c3 -s <span class="s2">&quot; &quot;</span> -t | sort -nr | nl | head -n10
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>降低当前网络速度质量(用于WIFI模拟手机2G环境)</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>ipfw pipe pipe_nr config bw B delay D queue Q plr P
</span><span class='line'><span class="se">\#</span>这里的 pipe_nr 指的是 pipe 规则编号，从 1~65535；
</span><span class='line'><span class="se">\#</span>B 是指频宽，可以表示为 bit/s、Kbit/s、Mbit/s、Bytes/s、KBytes/s、或 MBytes/s
</span><span class='line'><span class="se">\#</span>D 是延迟多少 milliseconds <span class="o">(</span>1/1000<span class="o">)</span>
</span><span class='line'><span class="se">\#</span>Q 是 queue size 的大小 <span class="o">(</span>单位为 packages 或 Bytes<span class="o">)</span>
</span><span class='line'><span class="se">\#</span>P 是要随机丢弃的封包数量。
</span></code></pre></td></tr></table></div></figure>


<p>*子目录含有.git导致不能加入版本管理</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>rm -rf mysubmodule/.gitgit
</span><span class='line'>rm --cached mysubmodule
</span></code></pre></td></tr></table></div></figure>


<p>*查看文件夹大小</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>du -sh * | sort -n
</span></code></pre></td></tr></table></div></figure>


<p>*查找当前文件夹下含有sr的文件行</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>grep -rn sr .
</span></code></pre></td></tr></table></div></figure>


<p>*比较区别</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>diff -y a.sr b.sr | nl
</span></code></pre></td></tr></table></div></figure>


<p>*查看端口占用</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>lsof -i:80
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[script]]></title>
    <link href="http://CodePeasant.github.io/blog/2013/12/04/script/"/>
    <updated>2013-12-04T20:36:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2013/12/04/script</id>
    <content type="html"><![CDATA[<h2><a href="http://CodePeasant.github.io/blog/2013/12/04/script-tips">常用脚本命令</a></h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[android]]></title>
    <link href="http://CodePeasant.github.io/blog/2013/12/04/android/"/>
    <updated>2013-12-04T20:30:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2013/12/04/android</id>
    <content type="html"><![CDATA[<p>Android基本上是在热聊被叫停后基本没什么事干的时候学的，就写了几个HelloWorld程序和复习了一遍OpenES,不过<a href="http://developer.android.com/training/index.html">Goodle的安卓学习课程</a>的确很赞，入门很不错.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS]]></title>
    <link href="http://CodePeasant.github.io/blog/2013/12/04/ios/"/>
    <updated>2013-12-04T19:25:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2013/12/04/ios</id>
    <content type="html"><![CDATA[<p>从理论上讲，我在爱奇艺的职位应该是iOS工程师，入职前的实习本来是做服务器端的，入职后奇谈的移动端缺人就改到白玉的小组做iOS了，虽然我没有半点移动开发的经验@@，感谢白玉的教材和指点。IOS其实上手还是挺简单的，开发逻辑也类似于MFC，学了两个星期就开始开发<a href="https://itunes.apple.com/cn/app/ai-qi-yi-re-liao/id663264968?mt=8">热聊</a>的剧照模块，然后又做了两个星期做好了以后就做一些直播、截图之类的下个版本的视频特性的试验。然后过了一段时间主程序员跑路了就负责交接XMPP的模块。再后来热聊就被叫停了&hellip;然后就换到了现在的部门，现在的工作留待以后再写。发一个热聊的遗照，纪念我做的第一个iOS项目.</p>

<p><img src="http://CodePeasant.github.io/images/page/hotChat.jpg" alt="热聊" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[大四]]></title>
    <link href="http://CodePeasant.github.io/blog/2012/10/17/%E5%A4%A7%E5%9B%9B/"/>
    <updated>2012-10-17T00:00:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2012/10/17/大四</id>
    <content type="html"><![CDATA[<h2>20120101</h2>

<p>新年新气象，写个记录。最终工作还是违约了IW改签了爱奇艺，IW的HRMM态度很好还免了违约金，很是感谢。过年后去北京实习，要北漂了，加油呀。</p>

<h2>20121121</h2>

<p>距离笔试一个月后，收到爱奇艺offer，工作内容比较喜欢，钱比较多，工作地点在北京一般，总评不错。</p>

<h2>20121025</h2>

<p>南航的offer拖了3个星期终于发了，工作内容一般，钱一般，工作地点在广州不错，总评一般，可惜我已经卖掉了@@。</p>

<h2>20121022</h2>

<p>三方发了，卖给IW，工作地点改上海，@@，开始过年&hellip;</p>

<h2>20121018</h2>

<p>今天跑了两趟西十二，百度还是不让霸笔， ，目测只能等下一个机会了。。。中午回来顺路去TPLink打了一下酱油意外收获第二个offer，工作内容一般，钱少的可怜，工作地点在深圳还不错，总评一般。</p>

<h2>20121017</h2>

<p>收到第一个offer，IW，工作内容比较喜欢，钱一般，工作地点在北京不想去，总评一般。</p>

<p>过了一个多月边考研边找工作的生活，想想还是找工作吧。一直在纠结，定下来也好，态度不端正感觉找工作还是有点难。找个一个月工作，海投了40多家，工作找起来也没原预期的势如破竹拿遍各种offer反而各种网申挂、笔试挂、一面挂、二面挂、三面挂、HR面挂，悲催如斯。仔细反思了一下，感觉海投还是不好，一天奔三四场宣讲笔试面试，在华科武大珞珈山酒店间跑来跑去，略累，也没有哪家公司是有好好准备的（又想起我亲爱的度娘， ）。笔试面试做起题来感觉还不如大二那会的水平。。。一年多没写什么代码，C++好多东西都忘了，STL和BOOST都用不顺手了，不止一次想不起容器的操作方法，感觉略坑。操作系统神马也不像大二考完软设、系分那么熟，好多东西都不会了，一问三不知，伤不起伤不起</p>

<p>看来还是得停业整顿，删掉一些公司，好好复习一下，再重新上路，加油。</p>
]]></content>
  </entry>
  
</feed>
