<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[乌衣巷]]></title>
  <link href="http://CodePeasant.github.io/atom.xml" rel="self"/>
  <link href="http://CodePeasant.github.io/"/>
  <updated>2014-11-04T18:48:00+08:00</updated>
  <id>http://CodePeasant.github.io/</id>
  <author>
    <name><![CDATA[吴逸翔]]></name>
    <email><![CDATA[1032197148@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[APUE笔记(Chapter 1~6)]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/10/31/APUE%E7%AC%94%E8%AE%B0%28Chapter1%7E6%29/"/>
    <updated>2014-10-31T21:15:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/10/31/APUE笔记(Chapter1~6)</id>
    <content type="html"><![CDATA[<h1>APUE笔记(Chapter 1~6)</h1>

<h2>1.UNIX System Overview</h2>

<h3>Nonfatal error(man 3 errno)</h3>

<ul>
<li>EAGAIN/EWOULDBLOCK</li>
<li>ENFILE/ENOBUFS/ENOLCK/ENOSPC/ENOSR/ENOMEM/EBUSY</li>
</ul>


<h3>键盘信号</h3>

<ul>
<li>Ctrl+Z SIGTSTP</li>
<li>Ctrl+C SIGINT</li>
<li>Ctrl+D EOF</li>
<li>Ctrl+/ SIGQUIT</li>
</ul>


<h2>2.UNIX Standardization and Implementations</h2>

<ul>
<li>ISO C/POSIX/XSI</li>
<li>FreeBSD/Linux/MacOS/Solaris</li>
<li>gcc -D_POSIX_C_SOURCE=200112 file.c</li>
</ul>


<h2>3.File I/O</h2>

<h3>open/close</h3>

<ul>
<li>O_RDONLY/O_WRONLY/O_RDWR</li>
<li>O_APPEND/O_TRUNC/O_CREAT/O_EXCL/O_NONBLOCK</li>
<li>O_SYNC(write data&amp;attr)/O_DSYNC(write data)/O_RSYNC(read)</li>
<li>sync(all)/fsync(single)/fdatasync</li>
</ul>


<h3>read/write</h3>

<h3>lseek</h3>

<ul>
<li>SEEK_CUR/SEEK_SET/SEEK_END</li>
<li>pread/pwrite: lseek+read/write</li>
</ul>


<h3>dup/dup2</h3>

<ul>
<li>dup(fd): fcntl(fd, O_DUPFD, 0)</li>
<li>dup2(fd1, fd2): close(fd2);fcntl(fd1, O_DUPFD, fd2)</li>
</ul>


<h3>fcntl</h3>

<ul>
<li>F_DUPFD</li>
<li>F_GETFD/F_SETFD(file descriptor, FD_CLOEXEC only)</li>
<li>F_GETFL/F_SETFL(file status, O_NONBLOCK and so on)</li>
<li>F_GETOWN/F_SETOWN</li>
<li>F_GETLK/F_SETLK/F_SETLKW</li>
<li>ioctl(driver, no need to known)</li>
</ul>


<h2>4.Files and Directories</h2>

<h3>stat(file path)/fstat(file decriptor id)/lstat(show symbolic link)</h3>

<ul>
<li>st_mode(file type&amp;permission)</li>
<li>st_ino/st_dev/st_rdev</li>
<li>st_nlink</li>
<li>st_uid/st_gid</li>
<li>st_size</li>
<li>st_atime[ls -u] last access , read()</li>
<li>st_mtime[ls] last modify, write()</li>
<li>st_ctime[ls -c] last inode status chagne, chown()</li>
<li>st_blksize</li>
<li>st_blocks(number of disk block allocate)</li>
</ul>


<h3>File Type</h3>

<ul>
<li>Regular file(S_ISREG)</li>
<li>Directory file(S_ISDIR)</li>
<li>Block special file(S_ISBLK)</li>
<li>Character special file(S_ISCHR)</li>
<li>FIFO(S_ISFIFO)[named pipe]</li>
<li>Socket(S_ISSOCK)</li>
<li>Symbolic link(S_ISLNK)</li>
</ul>


<h3>IPC</h3>

<ul>
<li>MQ message queue</li>
<li>SEM semaphore</li>
<li>SHM shared memory object</li>
</ul>


<h3>Process uid/gid</h3>

<ul>
<li>real userID/groudID(who excute the process)</li>
<li>effective userID/groupID(the permisson check)[by default is real userID/groupID, use set-user-id to be the file owner]</li>
<li>saved set-user-ID/groud-ID(save the last effective when effective change)</li>
<li>supplement group IDs</li>
</ul>


<h3>File Access Permissions</h3>

<ul>
<li>R:4, W :2, X:1</li>
<li>S_I(R/W/X)(USR/GRP/OTH)</li>
<li>open file need X for directory(if you known this file, R is no need)</li>
<li>list file need R for directory</li>
<li>create/ delete file need W&amp;X for directory, W for file is no need</li>
<li>access(path, mode): access permission test</li>
<li>umask(cmask): set the access permission for file this process create, turn off the bit in cmask</li>
<li>fchmod(fd, mode)</li>
</ul>


<h3>chown/fchown/lchown</h3>

<ul>
<li>chwon(path,owner,group)</li>
<li>chown -R user:group file/directory</li>
</ul>


<h3>file system</h3>

<ul>
<li>driver/parition(one file system per partition)/cylinde/(inodes+blocks)</li>
<li>a inode is a file, point to many data block</li>
<li>a inode can be link from many directory, when not process open the file and all directory unlink, delete the inode, but the data block still exist[hard link, just add st_nlink, create hard link for directory is not allowed]</li>
<li>symbolic link: add a new inode point to source file path, no add st_nlink</li>
<li>link(oldpath,newpath), symlink(actualpath,sympath), unlink(path), remove(path), rename(old,new)</li>
<li>mkdir/rmdir/chdir/fchdir/getcwd</li>
<li>opendir/readdir/rewinddir/closedir/telldir/seekdir</li>
<li>DIR structure like FILE, with the offset</li>
<li>st_dev: major is the disk num, minor is the filesystem num</li>
<li>st_rdev: valid for character device &amp; block device, the real device it is on</li>
</ul>


<h2>5.Standard I/O Library</h2>

<h3>Stream Buffer</h3>

<ul>
<li>Fully Buffered</li>
<li>Line Buffered</li>
<li>Unbuffered</li>
</ul>


<h3>Stream Read&amp;Write</h3>

<h4>Character-at-a-time I/O:</h4>

<ul>
<li>getc(fp)/fgetc(fp)/getchar()</li>
<li>getchar()=getc(STDIN)</li>
<li>getc is macro and fgetc is function, they are same</li>
<li>ungetc(c,fp)[put char back into stream]</li>
<li>putc(c, fp)/fputc(c, fp)/putchar&copy;</li>
</ul>


<h4>Line-at-a-time I/O:</h4>

<ul>
<li>fgets(buf,n,fp)</li>
<li>fputs(str,fp)</li>
</ul>


<h4>Direct I/O(Binary I/O):</h4>

<ul>
<li>fread(ptr, size, n, fp)</li>
<li>fwrite(ptr, size, n, fp)</li>
<li>ftell(fp)/fseek(fp, offset, whence)/rewind(fp)</li>
</ul>


<h3>Formatted I/O</h3>

<ul>
<li>printf(format, &hellip;)</li>
<li>fprintf(fp, format, ..)</li>
<li>sprintf(buf, format, ..)</li>
<li>snprintf(buf, n, format, &hellip;)</li>
<li>scanf(format, &hellip;)</li>
<li>fscanf(fp, format, &hellip;)</li>
<li>sscanf(buf, format, &hellip;)</li>
</ul>


<h3>Temporary Files</h3>

<ul>
<li>char *tmpname(ptr)</li>
<li>char *tempnam(directory, prefix)</li>
<li>File* tmpfile()</li>
<li>int mktemp(template)[return fd]</li>
<li>tmpname&amp;tempnam都有time window问题，应使用temfile&amp;mktemp</li>
</ul>


<h2>6.System Data Files and Information</h2>

<h3>Password File</h3>

<ul>
<li>passwd <em>getpwuid(uid)/passwd </em>getpwnam(name)</li>
<li>passwd *getpwent()[get by next, null return by end]</li>
<li>setpwent()[open/rewind]</li>
<li>endpwent()[close]</li>
</ul>


<h3>Shadow File(保存加密后的密码)</h3>

<ul>
<li>spwd *getspnam(name)</li>
<li>spwd *getspent()/setspent()/endspent()</li>
</ul>


<h3>Group File</h3>

<ul>
<li>group <em>getgrgid(gid)/group </em>getgrnam(name)</li>
<li>group *getgpent()/setgrent()/endgrent()</li>
<li>char **group->gr_mem指向属于本group的user_name</li>
<li>Supplementary Group IDs make a user can belong up to 16 addtional groups</li>
</ul>


<h3>Datetime</h3>

<ul>
<li>time_t time(time_t *) seconds from Epoch</li>
<li>gettimeofday(timeval *, NULL) seconds &amp; microseconds from Epoch</li>
<li>tm <em>gmtime(time_t </em>) time_t to tm UTC(calendar form)</li>
<li>tm <em>localtime(time_t </em>) time_t to tm local timezone</li>
<li>time_t mktime(tm *) tm to time_t</li>
<li>char <em>asctime(tm </em>) tm to string</li>
<li>char <em>ctime(time_t </em>) time_t to string</li>
<li>strftime(buf, maxsize, format, tm*) tm to format string</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++类型转换笔记]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/07/22/C%2B%2B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%AC%94%E8%AE%B0/"/>
    <updated>2014-07-22T21:19:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/07/22/C++类型转换笔记</id>
    <content type="html"><![CDATA[<h1>C语言默认</h1>

<ul>
<li>int(a)</li>
<li>(int)a</li>
</ul>


<h1>std::static_cast</h1>

<ul>
<li>效果同C语言默认</li>
<li>派生类向上转换为基类（安全）</li>
<li>基类向下转换为派生类（不安全，必须程序员保证）</li>
</ul>


<h1>std::dynamic_cast</h1>

<ul>
<li>基类向下转换为派生类（安全）</li>
<li>引用的话抛出std::bad_cast，指针返回空指针</li>
<li>运行时检查，依赖于虚函数表，基类必须有虚函数，效率比static_cast低</li>
</ul>


<h1>std::reinterpret_cast</h1>

<ul>
<li>把任意一个指针或算术类型转为任意其他指针或算术类型</li>
<li>一般只用于把指针转为int或int转为指针</li>
</ul>


<h1>std::const_cast</h1>

<ul>
<li>用来去掉变量的const/volatile属性</li>
</ul>


<h1>boost::polymorphic_cast</h1>

<ul>
<li>与dynamic_cast类型，但指针和引用转换失败都抛出std::bad_cast</li>
</ul>


<h1>boost::polymorphic_downcast</h1>

<ul>
<li>debug使用dynamic_cast，release使用static_cast</li>
<li>貌似能提高效率，但一般不要使用</li>
</ul>


<h1>boost::numeric_cast</h1>

<ul>
<li>用来防止较大的类型转成较小类型的数值回绕问题和有符号数转为无符号数的符号错误，失败抛出boost::bad_numeric_cast</li>
<li>doulbe转成float如果只是损失小数点精度的话不会抛出异常</li>
<li>sizeof(T)/std::numeric_limits<T>::max()获得类型的大小</li>
</ul>


<h1>boost::lexical_cast</h1>

<ul>
<li>把数值类型转为字符串类型 string a = boost::lexical_cast<string>(123)</li>
<li>把字符串类型转为数值类型 int a = boost::lexical_cast<int>(&ldquo;12&rdquo;)</li>
<li>失败抛出bad_lexical_cast</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mutex&Lock笔记]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/07/22/Mutex%26Lock%E7%AC%94%E8%AE%B0/"/>
    <updated>2014-07-22T21:15:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/07/22/Mutex&Lock笔记</id>
    <content type="html"><![CDATA[<h1>Mutex</h1>

<h2>Eclusive Ownership</h2>

<ul>
<li>mutex，一个简单的mutex只能被锁住一次，假如同一线程试图两次锁定mutex，将会产生死锁。</li>
<li>recursive mutex，一个线程可以多次锁定一个mutex，但必须以同样的次数对mutex进行解锁，否则其他线程将无法锁定该mutex。</li>
<li>shared mutex，多个线程读，单个线程写，lock/shared_lock，使用一个unique_lock和一个shared_lock对一个shared_mutex操作可以实现读写锁</li>
</ul>


<h2>获取锁行为</h2>

<ul>
<li>等待并试图对mutex加锁，直到没有其他线程锁定mutex；</li>
<li>试图对mutex加锁，并立即返回，假如其他线程锁定了mutex；</li>
<li>等待并试图对mutex加锁，直到没有其他线程锁定mutex或者直到规定的时间已过。</li>
</ul>


<h2>分类</h2>

<ul>
<li>mutex(try_mutex)</li>
<li>timed_mutex</li>
<li>recursive_mutex</li>
<li>recursive_timed_mutex</li>
<li>shared_mutex</li>
</ul>


<h1>Lock</h1>

<h2>分类</h2>

<ul>
<li>lock_guard 利用RAII的最简单实现</li>
<li>unique_lock 在lock_guard的基础上提供了try_lock()/timed_lock</li>
<li>shared_lock 读写锁中的读锁</li>
<li>upgrade_lock  未明</li>
</ul>


<h1>Reference</h1>

<ul>
<li><a href="http://www.boost.org/doc/libs/1_41_0/doc/html/thread/synchronization.html">Boost Synchronization</a></li>
<li><a href="http://zh.highscore.de/cpp/boost/multithreading.html">Boost多线程</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ Tip]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/07/22/cpp-tips/"/>
    <updated>2014-07-22T21:12:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/07/22/cpp-tips</id>
    <content type="html"><![CDATA[<h1>C++</h1>

<ul>
<li>虚函数是为了用基类指针能调用子类函数，虚函数必须有实现</li>
<li>纯虚函数是为了使类不能被实例化定义接口。纯虚函数只有声明</li>
<li>基类向下转型成派生类</li>
<li>定义构造函数、复制构造函数、或赋值操作符三个中的任意一个,你也需要定义另外两个</li>
<li>使用class a:private boost::non copyable</li>
<li>泛型是水平的，把各种不同的互相没有什么关系的类型应用于同一种算法；继承是垂直的，从抽象到具体，子类和父类是有关系的。</li>
</ul>


<h1>Linux</h1>

<ul>
<li>一个线程结束时要通过pthread_join或者pthread_detach(pthread_self())来释放8K左右的堆栈和线程描述符</li>
<li>interrupt只有在代码执行到wait/join/sleep这三种检查点的时候才会中断</li>
</ul>


<h1>Others</h1>

<ul>
<li>聚合：离散聚合/累积聚合/滑动聚合</li>
<li>旋转：开放架构(id/attr/val)与Cube</li>
<li>UnitTest:Setup/Exercice/Verify/Teardown</li>
<li>gtest事件：Enviroment(SetUp/TearDown)/TestSuite(SetUp/TearDownTestCase)/TestCase(SetUp/TearDown)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IO笔记]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/07/12/IO%E7%AC%94%E8%AE%B0/"/>
    <updated>2014-07-12T20:15:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/07/12/IO笔记</id>
    <content type="html"><![CDATA[<h2>Socket基本操作</h2>

<h3>TCP</h3>

<ul>
<li>Server:bind/listen/accept/read(write)/close</li>
<li>Client:bind/connect/read/write/close</li>
</ul>


<h3>UDP</h3>

<ul>
<li>Server:bind/sendto/recvfrom/close</li>
<li>Client:sendto/recvfrom/close</li>
</ul>


<h2>同步/异步/阻塞/非阻塞</h2>

<ul>
<li>同步 bool do();</li>
<li>异步 void do(); 事件:void onResult(bool result);[通知方式]</li>
<li>阻塞 直到数据就绪为止</li>
<li>非阻塞 不管数据有没有就绪直接返回</li>
<li>同步下区分阻塞和非阻塞，异步不区分，三种系统I/O:同步阻塞/同步非阻塞/异步非阻塞</li>
</ul>


<h2>Reactor/Proactor</h2>

<h3>组成元素</h3>

<ul>
<li>事件源(fd/socket)</li>
<li>事件多路分发机制(select/poll)</li>
<li>Reactor(事件注册/循环/回调/移除)</li>
<li>Event Handler(事件处理方法)</li>
</ul>


<h3>区别</h3>

<ul>
<li>reactor通知好的时候数据还没有写入缓冲区，需要自己去读写(同步)[libevent]</li>
<li>proactor通知好的时候操作系统已经把数据写入缓冲区，不需要自己去读写(异步)[asio]</li>
</ul>


<h3>Reference</h3>

<ul>
<li><a href="http://blog.csdn.net/sparkliang/article/details/4957744">libevent源码深度剖析</a></li>
<li><a href="http://www.boost.org/doc/libs/1_55_0/doc/html/boost_asio.html">boost.asio</a></li>
</ul>


<h1>select/poll/epoll/kqueue</h1>

<p>本质都是多路复用机制，select/poll都是轮询内核，epoll/kqueue采用中断信号回调</p>

<ul>
<li><p>select的缺点如下：</p>

<blockquote><ul>
<li>最大并发数（默认1024/2048）</li>
<li>效率（线性扫描，O(N)，活跃不活跃都要测试，大量不活跃的时候性能很差）</li>
<li>内核/用户空间（采用内存拷贝）</li>
</ul>
</blockquote></li>
<li><p>poll修正了最大并发数问题</p></li>
<li>epoll修正了最大并发数，效率（只跟活跃有关，O(k)），内核/用户空间（共享内存）</li>
<li>kqueue类似于epoll，不同平台的实现</li>
</ul>


<h2>边缘/水平触发</h2>

<ul>
<li>边缘触发(level)

<blockquote><p>每当状态变化时发生一个io事件；
有事了，告诉你一次，你不处理？拉倒！</p></blockquote></li>
<li>水平触发(edge)

<blockquote><p>只要满足条件就发生一个io事件；
有事了，你不处理？不断骚扰你直到你处理</p></blockquote></li>
</ul>


<h1>TCP/UDP</h1>

<ul>
<li>TCP要点有四，一曰有连接，二曰可靠传输，三曰数据按照到达，四曰端到端流量控制。</li>
<li>IP层提供的核心基本功能有两点，第一点是地址管理，第二点就是路由选路。</li>
<li>TCP3次握手,4次挥手用于保证双方都终止数据传输</li>
<li>UDP可以一个Client Socket连多个Server，TCP只能一对一</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式笔记]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/07/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    <updated>2014-07-10T20:15:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/07/10/设计模式笔记</id>
    <content type="html"><![CDATA[<h2>分类</h2>

<h3>创建（5+1）</h3>

<ul>
<li>工厂(Factory)</li>
<li>简单工厂(Simple Factory)</li>
<li>抽象工厂(Abstract Factory)</li>
<li>原型(Protoype)</li>
<li>单例(Singleton)</li>
<li>建造者(Builder)</li>
</ul>


<h3>结构（7）</h3>

<ul>
<li>组合(Composite)</li>
<li>代理(Proxy)</li>
<li>装饰(Decorator)</li>
<li>桥接(Bridge)</li>
<li>享元(Flyweight)</li>
<li>适配器(Adaptor)</li>
<li>外观(Facade)</li>
</ul>


<h3>行为（11）</h3>

<ul>
<li>模板方法(Template Method)</li>
<li>状态(State)</li>
<li>策略(Strategy)</li>
<li>观察者(Observer)</li>
<li>迭代器(Iterator)</li>
<li>责任链(Chain of Responsibility)</li>
<li>命令(Command)</li>
<li>访问者(Visitor)</li>
<li>备忘录(Memento)</li>
<li>中介者(Mediator)</li>
<li>解释器(Intepretor)</li>
</ul>


<h2>TIP</h2>

<ul>
<li>代理模式用于控制访问，用户不知道被代理的对象；装饰器模式用于新增行为，用户知道被被装饰的对象并在构造函数中传递给装饰器。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式笔记]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/07/10/%E6%A8%A1%E6%9D%BF.md.tmp/"/>
    <updated>2014-07-10T20:15:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/07/10/模板.md.tmp</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据库笔记]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/07/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    <updated>2014-07-06T20:15:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/07/06/数据库范式笔记</id>
    <content type="html"><![CDATA[<h2>范式比较</h2>

<h3>1NF</h3>

<p>数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。</p>

<h3>2NF</h3>

<p>非主属性完全依赖于主键[消除非主属性对主码的<strong>部分函数依赖</strong>]</p>

<h3>3NF</h3>

<p>非主属性不依赖于其它非主属性[消除了非主属性<strong>传递依赖</strong>]</p>

<h3>BCNF</h3>

<p>所有属性不依赖于任何候选关键字（一个表中只能有一个候选关键字）[消除了主属性<strong>传递依赖</strong>]</p>

<h3>4NF</h3>

<h3>5NF</h3>

<h2>概念定义</h2>

<h3>多值依赖</h3>

<p>设R(U)是一个属性集合U上的一个关系模式，X, Y, 和Z是U的子集，并且Z=U-X-Y，多值依赖X->&ndash;>Y成立当且仅当对R的任一个关系r，r在(X,Z)上的每个值对应一组Y的值，这组值仅仅决定于X值而与Z值无关。
若X->&ndash;>Y，而Z=空集，则称X->&ndash;>Y为平凡的多值依赖。
否则，称X->&ndash;>Y为非平凡的多值依赖。</p>

<h3>函数依赖</h3>

<p>可以看出，如果把上面的一组改为一个，那么多值依赖就变成了函数依赖。当然一个值组成的组也是组，所以说，函数依赖是多值依赖的特殊情况。</p>

<h2>TIP</h2>

<ul>
<li>1NF~BCNF消除函数依赖，4NF~5NF消除多值依赖</li>
<li>2NF-3NF都消除了数据冗余、更新异常、插入异常和删除异常</li>
</ul>


<h2>参考</h2>

<p><a href="http://www.bkent.net/Doc/simple5.htm">A Simple Guide to Five Normal Forms in Relational Database Theory</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[智能指针笔记]]></title>
    <link href="http://CodePeasant.github.io/blog/2014/07/04/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AC%94%E8%AE%B0/"/>
    <updated>2014-07-04T19:25:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2014/07/04/智能指针笔记</id>
    <content type="html"><![CDATA[<h2>std::auto_ptr</h2>

<h3>定义</h3>

<p>通过在析构函数里delete实现自动内存释放，实现大概50行代码以内</p>

<h3>TIP</h3>

<ul>
<li>一个原始指针只能有一个auto_ptr拥有其所有权</li>
<li>不支持值语义，赋值、拷贝操作之间转移所有权，原来的autor_ptr拥有一个空指针</li>
<li>不支持值语义所以不能放入STL容器中</li>
<li>使用delete所以不能传入数组指针</li>
</ul>


<h2>boost::scoped_ptr</h2>

<h3>TIP</h3>

<ul>
<li>实现原理与auto_ptr类似，不过不支持赋值、拷贝操作，其余类似</li>
<li>超出智能指针作用域利用析构自动delete故称为scoped，RAII</li>
</ul>


<h2>boost::scoped_array</h2>

<h3>TIP</h3>

<ul>
<li>实现与scoped_ptr一样，只不过是用delete[]来释放内存</li>
<li>一般用vector而不要用这个</li>
</ul>


<h2>boost::shared_ptr</h2>

<h3>定义</h3>

<p>引用计数指针可以分为intrusive和non-intrusive两种，shared_ptr是一种non-instrusive的引用计数智能指针。</p>

<h3>TIP</h3>

<ul>
<li>一个原始指针只能有可以有多个shared_ptr拥有其所有权</li>
<li>shared_ptr可以放入容器之中</li>
<li>类型转换必须用static_pointer_cast</li>
<li>删除器必须是一个实现了operator()的函数对象或者函数指针</li>
<li>删除器函数对象示例boost::shared_ptr<FILE> my_shared_file(f,FileCloser());</li>
<li>删除器函数指针示例boost::shared_ptr<FILE> my_shared_file(f,&amp;fclose);</li>
<li>使用enable_shared_from_this:因为shared_ptr(T<em>)会认为只有他拥有T</em>，故新建立一个引用计数，为0时进行一次delete；而share_ptr(weak_ptr&lt;T<em>>)沿用原有的weak_ptr计数+1；shared_from_this实际是share_ptr(weak_ptr&lt;T</em>>);故当有函数的参数是shared_ptr<T>的时候T应当继承enable_shared_from_this</li>
</ul>


<h2>boost::shared_array</h2>

<h3>TIP</h3>

<ul>
<li>实现与shared_ptr一样，只不过是用delete[]来释放内存</li>
<li>一般用一个指向vector的shared_ptr指针而不要用这个</li>
</ul>


<h2>boost::intrusive_ptr</h2>

<h3>定义</h3>

<p>intrusive的引用计数智能指针，需要用户自己维护一个引用计数，并重载intrusive_ptr_add_ref和instrusive_ptr_release函数</p>

<h3>TIP</h3>

<ul>
<li>直接可以使用this而不需要像share_ptr要用enable_shared_from_this</li>
<li>一般还是用shared_ptr</li>
<li>据说智能指针的大小必须与裸指针的大小相等时也要用instrusive_ptr</li>
</ul>


<h2>boost::weak_ptr</h2>

<h3>定义</h3>

<p>weak_ptr不增加引用计数</p>

<h3>TIP</h3>

<ul>
<li>可以观察资源并通过expired防止悬空指针</li>
<li>用于防止循环引用</li>
<li>生成shared_ptr:(1)通过构造函数构造(为空返回bad_weak_ptr);(2)通过lock方法(为空返回空shared_ptr)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[有用的Shell命令和小技巧]]></title>
    <link href="http://CodePeasant.github.io/blog/2013/12/04/script-tips/"/>
    <updated>2013-12-04T20:38:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2013/12/04/script-tips</id>
    <content type="html"><![CDATA[<ul>
<li>在某个目录下查找含有某段文字的文件</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>grep QLStagePhoto -rl branches/
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>统计一个命令的运行时间</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">time </span>ls
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Ctrl+A 跳到当前行最前</li>
<li>Ctrl+U 清空当前行</li>
<li>Ctrl+I 清空整屏</li>
<li><p>一般输入某个命令加-h选项可以以利于人类阅读的方式显示，如ll -h/df -h</p></li>
<li><p>统计字符数/词数/行数</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>ls|wc -c/w/l
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>重复上个输入的命令</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>sudo !!
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>以当前目录为根目录启动HTTPServer，端口为8000</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>python -m SimpleHTTPServer
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>统计当前用户最常用的10个命令</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">history</span> | awk <span class="s1">&#39;{CMD[$2]++;count++;} END { for (a in CMD )print CMD[a] &quot; &quot; CMD[a]/count*100 &quot;% &quot; a }&#39;</span> | grep -v <span class="s2">&quot;./&quot;</span> | column -c3 -s <span class="s2">&quot; &quot;</span> -t | sort -nr | nl | head -n10
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>降低当前网络速度质量(用于WIFI模拟手机2G环境)</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>ipfw pipe pipe_nr config bw B delay D queue Q plr P
</span><span class='line'><span class="se">\#</span>这里的 pipe_nr 指的是 pipe 规则编号，从 1~65535；
</span><span class='line'><span class="se">\#</span>B 是指频宽，可以表示为 bit/s、Kbit/s、Mbit/s、Bytes/s、KBytes/s、或 MBytes/s
</span><span class='line'><span class="se">\#</span>D 是延迟多少 milliseconds <span class="o">(</span>1/1000<span class="o">)</span>
</span><span class='line'><span class="se">\#</span>Q 是 queue size 的大小 <span class="o">(</span>单位为 packages 或 Bytes<span class="o">)</span>
</span><span class='line'><span class="se">\#</span>P 是要随机丢弃的封包数量。
</span></code></pre></td></tr></table></div></figure>


<p>*子目录含有.git导致不能加入版本管理</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>rm -rf mysubmodule/.gitgit
</span><span class='line'>rm --cached mysubmodule
</span></code></pre></td></tr></table></div></figure>


<p>*查看文件夹大小</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>du -sh * | sort -n
</span></code></pre></td></tr></table></div></figure>


<p>*查找当前文件夹下含有sr的文件行</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>grep -rn sr .
</span></code></pre></td></tr></table></div></figure>


<p>*比较区别</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>diff -y a.sr b.sr | nl
</span></code></pre></td></tr></table></div></figure>


<p>*查看端口占用</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>lsof -i:80
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[script]]></title>
    <link href="http://CodePeasant.github.io/blog/2013/12/04/script/"/>
    <updated>2013-12-04T20:36:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2013/12/04/script</id>
    <content type="html"><![CDATA[<h2><a href="http://CodePeasant.github.io/blog/2013/12/04/script-tips">常用脚本命令</a></h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[android]]></title>
    <link href="http://CodePeasant.github.io/blog/2013/12/04/android/"/>
    <updated>2013-12-04T20:30:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2013/12/04/android</id>
    <content type="html"><![CDATA[<p>Android基本上是在热聊被叫停后基本没什么事干的时候学的，就写了几个HelloWorld程序和复习了一遍OpenES,不过<a href="http://developer.android.com/training/index.html">Goodle的安卓学习课程</a>的确很赞，入门很不错.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS]]></title>
    <link href="http://CodePeasant.github.io/blog/2013/12/04/ios/"/>
    <updated>2013-12-04T19:25:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2013/12/04/ios</id>
    <content type="html"><![CDATA[<p>从理论上讲，我在爱奇艺的职位应该是iOS工程师，入职前的实习本来是做服务器端的，入职后奇谈的移动端缺人就改到白玉的小组做iOS了，虽然我没有半点移动开发的经验@@，感谢白玉的教材和指点。IOS其实上手还是挺简单的，开发逻辑也类似于MFC，学了两个星期就开始开发<a href="https://itunes.apple.com/cn/app/ai-qi-yi-re-liao/id663264968?mt=8">热聊</a>的剧照模块，然后又做了两个星期做好了以后就做一些直播、截图之类的下个版本的视频特性的试验。然后过了一段时间主程序员跑路了就负责交接XMPP的模块。再后来热聊就被叫停了&hellip;然后就换到了现在的部门，现在的工作留待以后再写。发一个热聊的遗照，纪念我做的第一个iOS项目.</p>

<p><img src="http://CodePeasant.github.io/images/page/hotChat.jpg" alt="热聊" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[大四]]></title>
    <link href="http://CodePeasant.github.io/blog/2012/10/17/%E5%A4%A7%E5%9B%9B/"/>
    <updated>2012-10-17T00:00:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2012/10/17/大四</id>
    <content type="html"><![CDATA[<h2>20120101</h2>

<p>新年新气象，写个记录。最终工作还是违约了IW改签了爱奇艺，IW的HRMM态度很好还免了违约金，很是感谢。过年后去北京实习，要北漂了，加油呀。</p>

<h2>20121121</h2>

<p>距离笔试一个月后，收到爱奇艺offer，工作内容比较喜欢，钱比较多，工作地点在北京一般，总评不错。</p>

<h2>20121025</h2>

<p>南航的offer拖了3个星期终于发了，工作内容一般，钱一般，工作地点在广州不错，总评一般，可惜我已经卖掉了@@。</p>

<h2>20121022</h2>

<p>三方发了，卖给IW，工作地点改上海，@@，开始过年&hellip;</p>

<h2>20121018</h2>

<p>今天跑了两趟西十二，百度还是不让霸笔， ，目测只能等下一个机会了。。。中午回来顺路去TPLink打了一下酱油意外收获第二个offer，工作内容一般，钱少的可怜，工作地点在深圳还不错，总评一般。</p>

<h2>20121017</h2>

<p>收到第一个offer，IW，工作内容比较喜欢，钱一般，工作地点在北京不想去，总评一般。</p>

<p>过了一个多月边考研边找工作的生活，想想还是找工作吧。一直在纠结，定下来也好，态度不端正感觉找工作还是有点难。找个一个月工作，海投了40多家，工作找起来也没原预期的势如破竹拿遍各种offer反而各种网申挂、笔试挂、一面挂、二面挂、三面挂、HR面挂，悲催如斯。仔细反思了一下，感觉海投还是不好，一天奔三四场宣讲笔试面试，在华科武大珞珈山酒店间跑来跑去，略累，也没有哪家公司是有好好准备的（又想起我亲爱的度娘， ）。笔试面试做起题来感觉还不如大二那会的水平。。。一年多没写什么代码，C++好多东西都忘了，STL和BOOST都用不顺手了，不止一次想不起容器的操作方法，感觉略坑。操作系统神马也不像大二考完软设、系分那么熟，好多东西都不会了，一问三不知，伤不起伤不起</p>

<p>看来还是得停业整顿，删掉一些公司，好好复习一下，再重新上路，加油。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[大三]]></title>
    <link href="http://CodePeasant.github.io/blog/2011/09/17/%E5%A4%A7%E4%B8%89/"/>
    <updated>2011-09-17T00:00:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2011/09/17/大三</id>
    <content type="html"><![CDATA[<h2>110927</h2>

<p>89.14&amp;99，保持这种状态，好好努力</p>

<h2>110926</h2>

<p>今天是很累的一天，身体累心也累，对一些事情的处理能力还有待加强，向男哥看齐。</p>

<h2>11092</h2>

<p>今天知道辉哥放弃保研挺震惊的，也聊了挺久，多了很多感触，读研和工作，如何选择，其实还是比较难想的。有时我也在想我是不是要那么执着于去一个更好的学校的读个研究生？是为了提高自己抑或只是为了镀镀金。。。算了，还是坚持目前的基本路线吧，动摇来动摇去反而不好。又聊起技术，发现我最近研究的东西越来越偏表层和美工，辉哥说了C++和算法才是核心竞争力，我一直以来也是这样想的，但总是对各种各样的技术很好奇，各种研究，从VB到Java/PHP，从OpenGL到GoogleMaps，从css/js到HTML5/CSS3，从Test到Bugfix，到各种工具软件的使用，貌似我的兴趣一直在各种变，学得也不够精，C++过后我再也不敢说我熟悉某一种语言了，C++
实际上也是有很多问题的，STL/boost/Linux C++/QT很多很重要的东西我都只学了皮毛，有时总有种C/S已死，web当立的感觉，盲目的追求各种潮流，很纠结，主要也是目标不确定。最近的事情也很多，令人无力吐槽的某项目，力不从心却又不能不做的某项目，某本电子杂志，各场想去却又没时间的招聘会，看着淘宝人人腾讯百度一个个飘过或是即将飘过，有种恨不会分身术的感觉。学习上也很需要时间，目前的时间基本只能维持预习到老师讲的前面一点点，真怕像大一那样一个懈怠进度就落后了，还是需要时间去维持，好好学习。事情很多，主要还是自己当时没控制好应该做什么，什么事情应该拒绝或放弃，好吧，既然选择了就别后悔，用自己的努力去维护自己的光荣，work hard。</p>

<h2>110920</h2>

<p>尽管大二下已经比较努力地弥补加权了，大二的加权还是比较惨，算起来估计总成绩比某人还要少一些，TT&hellip;大二上自己选择了研究技术就别后悔，奋斗目标还是得选定了就别动摇，好吧，大三好好学习，挤出时间研究技术，吴逸翔你可以证明自己的，我相信你，好好奋斗。</p>

<h2>110916</h2>

<p>有时初始目的是好的，只是因为好奇或者是想展现自己的技术，却不小心变得有点像做坏事，有种道德的负罪感。好吧，到处为止，以后还是不要太好奇也不要逾越界限，安安分分过日子吧。</p>

<h2>110912</h2>

<p>还是会为某些人某些事高兴难过，还是有点容易激动，但已经进步很多了，加油，吴逸翔，心态再平和一点，内心强大的人才不会寂寞。</p>

<h2>111116</h2>

<p>很多东西压抑太久后释放出来才发现自己还是很脆弱，suzecenzezigen</p>

<h2>111222</h2>

<p>用了近五年的密码还是改了，不想承认，但还是一个时代的终结&hellip;</p>

<h2>120106</h2>

<p>下半学期来感觉得失心太强了，从成绩到Sose，感觉心态一直不对，太在意结果了反而一直很纠结，没有上半学期的什么都不想一心一意搞学习，改变自己那种平静的感觉。或许很多东西不经意间或许就得到了，太过于追求反而会越来越远。</p>

<h2>120108</h2>

<p>突然想不起当年我和苏泽是怎么度过那段打个游戏都会互相讥讽然后有时就变成吵架了的充满摩擦的岁月了，一个真实完整的现实中的人还是比一个只存在于脑海中的完美幻象好</p>

<h2>120212</h2>

<p>100&amp;91.81&amp;86.85，Keep working, keep moving</p>

<h2>120510</h2>

<p>继腾讯莫名其妙的挂了以后，百度也挂了，还挂在笔试，周三上午在考试间的空隙去老地方想要霸面然后不给，伤感。。。今天考试完重新看了一下机器学习/数据挖掘的岗位要求，突然发现要求的是硕士以上，有点坑爹，好吧，算我自己不够细心，应该低调点投C/C++的，百度的系统也有问题，缺乏错误提醒，吐槽一下，看来还是要读研，好好努力。</p>

<h2>120518</h2>

<p>西山居一面又变成去年腾讯一面的悲剧，每次都这样，我真的可能是谈吐中一直透着一股傲气和自大，多年习惯有点难改，还是得压一下。技术水平之外还是有很多东西&hellip;.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[大二]]></title>
    <link href="http://CodePeasant.github.io/blog/2010/09/27/%E5%A4%A7%E4%BA%8C/"/>
    <updated>2010-09-27T00:00:00+08:00</updated>
    <id>http://CodePeasant.github.io/blog/2010/09/27/大二</id>
    <content type="html"><![CDATA[<h2>100927</h2>

<p>今天评了奖学金，也参加了UniqueStudio的笔试，心情不是很好，唯一让我很开心的是：</p>

<p>今天上高一的群聊，跟算法的，还奕彤一边聊会计学经济学，另一边又跟房海灏聊计算机、算法。结果成功地让房海灏相信华科的财政学的人是会VC/VB/Java，懂数据结构会听说过退火、神经网络算法。。。发了几个程序，房某人深感惭愧，笑。。。</p>

<h2>101017</h2>

<p>哈哈，终于进Dian团队了，谢谢伟俊师兄和子敬师兄的指点和帮助，好开心啊。。。</p>

<h2>101023</h2>

<p>昨晚是海外组的通宵测试，试题是修正一个估计代码量不下50万行的软件的一个BUG,C++，和邹晓航合作工作还是很有效的，十二点多将错误定位到一个三万行代码的View.cpp中，可惜接下来的六个小时就没什么收获了，不过还好大家都差不多。。。这么大型的程序还是第一接触到，经验可能还是不足，等待晚上的结果吧。</p>

<h2>101024</h2>

<p>哈哈，原来我进海外组了，我还以为被刷了呢，虚惊一场。。。相对于做网页，我还是更喜欢做C++/Java/LISP开发的。今天第一次参加了点的例会，感觉很有激情，但刘玉有点凶。。。</p>

<h2>101107</h2>

<p>第二次例会 B102 深刻的一课 很多小事情只有出现了严重后果才被人重视，只是太晚了，不要随便说谎，诚信胜金。。。</p>

<h2>101112</h2>

<p>从Peon那里证实了甲虫说的某人被追走的消息，伤心。。。但跟陈泽的痛苦相比我还是应该惭愧的，好好学习，天天向上。LS和TH是我进大学的两个梦想，一个破灭了就专心于另一个吧，TH,wait for me&hellip;.</p>

<p>第三次例会C301，还是诚信似金的问题，但感觉刘玉有点矫枉过正了，上次 填表态表大家第一题都选A就是一个证明，很多人其实都有不同意见，但气氛不太对导致大家都不敢说出来了，这又导致了不诚信问题。很佩服今天在例会上谢创和柯尊尧的勇气，深感不如。。。突然想起60年代和文革的那段时期，很多知识分子都有一些看法，但政治气氛不对导致大家都不敢说话。。。</p>

<p>明天软考，早点睡吧。人品好一点应该能过，神般的吴逸翔。</p>

<h2>101115</h2>

<p>等考四级网络工程师如我所料的过了，只是只有良好，郁积，还以为是优秀。。。软考哥不求优秀，但求能过，慢慢等吧。。</p>

<h2>101125</h2>

<p>做了一星期的项目终于搞定了，代码和文档都写完了，我的第一个项目终于提交了，慢慢等结果吧，谢谢熊健和王慧松对我的指导。下周考试周，明天起又是得整天泡图书馆，悲催。。</p>

<h2>101128</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include&lt;iostream&gt;</span>
</span><span class='line'><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
</span><span class='line'>    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;吴逸翔很老很老了&quot;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>101208</h2>

<p>忙了三天，终于把项目重提交了，难啊。。。拜拜神兽，保佑我项目不挂！</p>

<h2>101210</h2>

<p>上午62，下午56，软考如我所料的过了，邹晓航你还欠我一顿饭。。。</p>

<h2>101216</h2>

<p>项目被判失败了，错误是因为VBUnit在VB6里需要配置而我忘了在Wink里演示，一个只需要点击几下的操作我却忘记了。。。</p>

<p>回想起这个项目，暴露出的全是我的粗心大意和自以为是：拿到项目的时候觉得难度不大，于是匆匆地把代码写好就提交了，wink和文档更是做的很糟糕。于是很果断的被打回来了，打回来是因为缺少录一个wink,于是重新录了一个wink和修改了提交文档觉得没问题了又重提交了，TAM运行了一下测试代码发现运行不起来，果断判失败，然后就出现了开头的一幕。。。</p>

<p>现在只能Communication了，希望TAM能给点耐心，看看我的wink，再次运行一下我的测试代码。。。</p>

<h2>110121</h2>

<p>概率论出来了，加权彻底崩溃了，这都是我的错，一学期都不去上课，一直以为期末可以看看书就可以像微积分一样再考个九十几然后再来嘲笑那些平时去上课的人们，吴逸翔，你为你的嚣张付出了代价！上学期的努力的成果又被我挥霍掉了，估计这次名次又掉回我刚转过来的水平了，活该！进步总是很艰难的，是一点一点积累起来的，稍有不慎就会很快的滑下来，这样的教训现在想起来数不胜数，然后我居然一直没有吸取教训，还嚣张到现在，可笑的吴逸翔。看了看课表，下学期的课我都不喜欢，但我要好好学，用心地学，不再缺任何一节课。下学期，除了考系分和做项目，我不再做任何与学习无关的事。</p>

<h2>110302</h2>

<p>虽然是自己选择离开，但还是觉得很心酸，新的开始。。。</p>

<h2>110507</h2>

<p>今天果断霸王笔了百度，百度还是预料到了这种情况，预留了很多名额，试题还可以，都是数据结构、算法、设计模式，一个熟练的程序员和懂一些软件工程的软设还是基本能搞定的，最后一题要根据两种属性进行查找，之前的可行性分析分太久了，16TB的数据还是比较麻烦的，最后一个属性用了hash查找一个只能用顺序查找，两个极端，囧&hellip;今天又见到了好多海外组的大神，旷创亮迟理等等，貌似整个海外都来了，感觉压力好大，貌似没什么竞争力，还是看RP吧。。。明天腾讯腾讯的客户端开发，好好考吧。。、</p>

<h2>110527</h2>

<p>百度的offer终究还是挂了，学生活动这东西虽然很扯还是要练一练的&hellip;</p>

<h2>110528</h2>

<p>SR, another LS.</p>

<h2>1100605</h2>

<p>흧蚈኶ä슷</p>

<h2>110707</h2>

<p>　　4ECA5929548C565653BB81EA4E60503C5F977EAA5FF576844E005929</p>

<p>总结：大二上基本泡在团队里做项目，怀念那种熬夜奋斗的感觉。加权跌得比较厉害，一课和二课间要找到平衡。大二下退出了团队，第一次参加了公司的面试，也知道了自己的大致水平，第一次向女生表白，有些曲折，但还是基本不算荒废了自己的时光。</p>
]]></content>
  </entry>
  
</feed>
